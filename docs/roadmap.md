# Tropical Fox - å®Ÿè£…ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—

## æ¦‚è¦

ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€æœ€æ–°ã®2Dã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ã®æ©Ÿèƒ½ã‚’ç¶²ç¾…ã—ãŸé•·æœŸå­¦ç¿’å‘ã‘ã®è©³ç´°ãªå®Ÿè£…è¨ˆç”»ã§ã™ã€‚Celesteã€Hollow Knightã€Oriã€Cupheadã€Dead Cellsãªã©ã®æœ€æ–°ã‚¿ã‚¤ãƒˆãƒ«ã‹ã‚‰å­¦ã‚“ã ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹ã‚’å®Ÿè£…ã—ã¦ã„ãã¾ã™ã€‚

**ç›®æ¨™**: å­¦ã³ãªãŒã‚‰ã€ç¾ä»£çš„ã§æ´—ç·´ã•ã‚ŒãŸ2Dã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ã‚’ä½œã‚‹

---

## é€²æ—ãƒˆãƒ©ãƒƒã‚«ãƒ¼

| Phase | åç§° | çŠ¶æ…‹ | é‡è¦åº¦ | é›£æ˜“åº¦ |
|-------|------|------|--------|--------|
| 0 | ç’°å¢ƒæ§‹ç¯‰ | ğŸ”µ TODO | â­â­â­ | â­ |
| 1 | åŸºç¤ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­â­â­ | â­ |
| 2 | ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŸºæœ¬å‹•ä½œ | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 3 | å…ˆé€²çš„ãªç§»å‹•ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­â­â­ | â­â­â­ |
| 4 | ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 5 | æˆ¦é—˜åŸºç¤ | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 6 | æ•µã‚·ã‚¹ãƒ†ãƒ I | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 7 | ãƒ¬ãƒ™ãƒ«ã‚·ã‚¹ãƒ†ãƒ åŸºç¤ | ğŸ”µ TODO | â­â­â­ | â­â­â­ |
| 8 | ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ I | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 9 | ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆI | ğŸ”µ TODO | â­â­ | â­â­ |
| 10 | UIã‚·ã‚¹ãƒ†ãƒ I | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 11 | èƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­â­â­ | â­â­â­ |
| 12 | æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ II | ğŸ”µ TODO | â­â­ | â­â­â­ |
| 13 | æ•µã‚·ã‚¹ãƒ†ãƒ II | ğŸ”µ TODO | â­â­ | â­â­â­ |
| 14 | ãƒœã‚¹ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­â­â­ | â­â­â­â­ |
| 15 | ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ— | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 16 | é€²è¡Œç®¡ç† | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 17 | UIã‚·ã‚¹ãƒ†ãƒ II | ğŸ”µ TODO | â­â­ | â­â­ |
| 18 | ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ I | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 19 | ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆII | ğŸ”µ TODO | â­â­ | â­â­â­â­ |
| 20 | ãƒ¬ãƒ™ãƒ«ã‚®ãƒŸãƒƒã‚¯ | ğŸ”µ TODO | â­â­ | â­â­ |
| 21 | ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ II | ğŸ”µ TODO | â­â­ | â­â­â­ |
| 22 | åé›†è¦ç´  | ğŸ”µ TODO | â­â­ | â­â­ |
| 23 | ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ II | ğŸ”µ TODO | â­ | â­â­â­ |
| 24 | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–I | ğŸ”µ TODO | â­â­â­ | â­â­â­ |
| 25 | ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ | ğŸ”µ TODO | â­â­ | â­â­ |
| 26 | ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­â­ | â­â­ |
| 27 | ã‚«ãƒƒãƒˆã‚·ãƒ¼ãƒ³/ãƒ€ã‚¤ã‚¢ãƒ­ã‚° | ğŸ”µ TODO | â­ | â­â­â­ |
| 28 | ã‚¿ã‚¤ãƒ ã‚¢ã‚¿ãƒƒã‚¯ | ğŸ”µ TODO | â­ | â­â­ |
| 29 | ãƒªãƒ—ãƒ¬ã‚¤ã‚·ã‚¹ãƒ†ãƒ  | ğŸ”µ TODO | â­ | â­â­â­â­ |
| 30 | ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–II | ğŸ”µ TODO | â­â­ | â­â­â­ |
| 31 | ãƒãƒªãƒƒã‚·ãƒ¥ | ğŸ”µ TODO | â­â­â­ | â­â­ |
| 32 | ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ (ã‚ªãƒ—ã‚·ãƒ§ãƒ³) | ğŸ”µ TODO | â­ | â­â­â­â­â­ |

**å‡¡ä¾‹**:
- ğŸ”µ TODO / ğŸŸ¡ é€²è¡Œä¸­ / ğŸŸ¢ å®Œäº† / âš« ã‚¹ã‚­ãƒƒãƒ—
- é‡è¦åº¦: â­(ä½) ~ â­â­â­(é«˜)
- é›£æ˜“åº¦: â­(ç°¡å˜) ~ â­â­â­â­â­(éå¸¸ã«é›£ã—ã„)

---

## Phase 0: ç’°å¢ƒæ§‹ç¯‰ï¼ˆäºˆæƒ³æ™‚é–“: 1-2æ—¥ï¼‰

### ç›®æ¨™
é–‹ç™ºç’°å¢ƒã‚’æ•´ãˆã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åŸºç›¤ã‚’ä½œã‚‹

### ã‚¿ã‚¹ã‚¯

#### 0.1 ä¾å­˜é–¢ä¿‚ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- [ ] Cargo.tomlã«Bevy 0.15ã‚’è¿½åŠ 
- [ ] RONã€serdeã‚’è¿½åŠ 
- [ ] bevy-inspector-eguiã‚’è¿½åŠ ï¼ˆdebug_mode featureï¼‰
- [ ] ãã®ä»–å¿…è¦ãªä¾å­˜é–¢ä¿‚

```toml
[dependencies]
bevy = { version = "0.15", default-features = false, features = [
    "bevy_winit", "bevy_render", "bevy_core_pipeline",
    "bevy_sprite", "bevy_text", "bevy_ui",
    "bevy_asset", "bevy_scene", "bevy_audio",
    "bevy_gilrs", "vorbis", "png", "x11"
] }
ron = "0.8"
serde = { version = "1.0", features = ["derive"] }

[features]
default = []
debug_mode = ["bevy-inspector-egui"]

[dependencies.bevy-inspector-egui]
version = "0.28"
optional = true
```

#### 0.2 ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ã®ä½œæˆ
- [ ] `src/`é…ä¸‹ã®ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹é€ ã‚’ä½œæˆ
- [ ] `assets/config/`ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’ä½œæˆ
- [ ] `docs/`é…ä¸‹ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ•´å‚™

```
src/
â”œâ”€â”€ main.rs
â”œâ”€â”€ game_state.rs
â”œâ”€â”€ components/
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ systems/
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ plugins/
â”‚   â”œâ”€â”€ mod.rs
â”‚   â””â”€â”€ core.rs
â”œâ”€â”€ resources/
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ events/
â”‚   â””â”€â”€ mod.rs
â”œâ”€â”€ config/
â”‚   â””â”€â”€ mod.rs
â””â”€â”€ debug/
    â””â”€â”€ mod.rs
```

#### 0.3 åŸºæœ¬çš„ãªmain.rsã®ä½œæˆ
- [ ] Bevyã‚¢ãƒ—ãƒªã®åˆæœŸåŒ–
- [ ] Stateã®å®šç¾©
- [ ] åŸºæœ¬ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ç™»éŒ²

```rust
use bevy::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest()))
        .run();
}
```

#### 0.4 ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†ã®è¨­å®š
- [ ] .gitignoreã®ç¢ºèª
- [ ] åˆæœŸã‚³ãƒŸãƒƒãƒˆ

### æˆæœç‰©
- ãƒ“ãƒ«ãƒ‰ãŒé€šã‚‹Bevy ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ
- ç©ºã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒè¡¨ç¤ºã•ã‚Œã‚‹

### å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹
- [Bevyå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://bevyengine.org/)
- [Bevy Cheatbook](https://bevy-cheatbook.github.io/)

---

## Phase 1: åŸºç¤ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 2-3æ—¥ï¼‰

### ç›®æ¨™
ã‚²ãƒ¼ãƒ ã®åŸºç›¤ã¨ãªã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰

### ã‚¿ã‚¹ã‚¯

#### 1.1 ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†
- [ ] `GameState` Enumã®å®šç¾©
- [ ] `InGameState` SubStateã®å®šç¾©
- [ ] çŠ¶æ…‹é·ç§»ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

```rust
#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]
pub enum GameState {
    #[default]
    Loading,
    Title,
    WorldMap,
    InGame,
    Paused,
    GameOver,
}

#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, SubStates)]
#[source(GameState = GameState::InGame)]
pub enum InGameState {
    #[default]
    StagePlay,
    BossRoom,
    StageTransition,
}
```

#### 1.2 CorePluginã®å®Ÿè£…
- [ ] ã‚«ãƒ¡ãƒ©ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- [ ] ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦è¨­å®šã®èª­ã¿è¾¼ã¿
- [ ] ã‚°ãƒ­ãƒ¼ãƒãƒ«ãƒªã‚½ãƒ¼ã‚¹ã®åˆæœŸåŒ–

#### 1.3 åŸºæœ¬çš„ãªç‰©ç†ã‚·ã‚¹ãƒ†ãƒ 
- [ ] é‡åŠ›ã®å®Ÿè£…
- [ ] Velocityã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] åŸºæœ¬çš„ãªä½ç½®æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ 

```rust
#[derive(Component)]
pub struct Velocity {
    pub x: f32,
    pub y: f32,
}

#[derive(Component)]
pub struct Gravity {
    pub scale: f32,
}

fn apply_gravity(
    time: Res<Time>,
    game_settings: Res<GameSettings>,
    mut query: Query<(&mut Velocity, &Gravity)>,
) {
    let gravity = game_settings.gameplay.gravity;
    for (mut velocity, grav) in &mut query {
        velocity.y -= gravity * grav.scale * time.delta_seconds();
    }
}

fn apply_velocity(
    time: Res<Time>,
    mut query: Query<(&mut Transform, &Velocity)>,
) {
    for (mut transform, velocity) in &mut query {
        transform.translation.x += velocity.x * time.delta_seconds();
        transform.translation.y += velocity.y * time.delta_seconds();
    }
}
```

#### 1.4 RONè¨­å®šã®èª­ã¿è¾¼ã¿
- [ ] GameSettingsæ§‹é€ ä½“ã®å®šç¾©
- [ ] RONèª­ã¿è¾¼ã¿é–¢æ•°
- [ ] game_settings.ronãƒ•ã‚¡ã‚¤ãƒ«ã®ä½œæˆ

### æˆæœç‰©
- çŠ¶æ…‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãŒå‹•ä½œ
- åŸºæœ¬çš„ãªç‰©ç†æ¼”ç®—ãŒå‹•ä½œ

---

## Phase 2: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åŸºæœ¬å‹•ä½œï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ç›®æ¨™
ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å‹•ã‹ã›ã‚‹ã‚ˆã†ã«ã™ã‚‹

### ã‚¿ã‚¹ã‚¯

#### 2.1 ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ã‚¹ãƒãƒ¼ãƒ³
- [ ] Playerã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®è¡¨ç¤º
- [ ] åˆæœŸä½ç½®ã®è¨­å®š

#### 2.2 å·¦å³ç§»å‹•ã®å®Ÿè£…
- [ ] ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã®å‡¦ç†
- [ ] æ°´å¹³æ–¹å‘ã®é€Ÿåº¦åˆ¶å¾¡
- [ ] å‘ãï¼ˆfacingï¼‰ã®ç®¡ç†

```rust
#[derive(Component)]
pub struct Player {
    pub facing_right: bool,
}

#[derive(Component)]
pub struct PlayerStats {
    pub move_speed: f32,
    pub acceleration: f32,
    pub deceleration: f32,
}

fn player_horizontal_movement(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Velocity, &mut Player, &PlayerStats)>,
    time: Res<Time>,
) {
    for (mut velocity, mut player, stats) in &mut query {
        let mut input = 0.0;

        if keyboard.pressed(KeyCode::ArrowLeft) || keyboard.pressed(KeyCode::KeyA) {
            input -= 1.0;
            player.facing_right = false;
        }
        if keyboard.pressed(KeyCode::ArrowRight) || keyboard.pressed(KeyCode::KeyD) {
            input += 1.0;
            player.facing_right = true;
        }

        let target_velocity = input * stats.move_speed;

        // ã‚¹ãƒ ãƒ¼ã‚ºãªåŠ é€Ÿ/æ¸›é€Ÿ
        if input != 0.0 {
            velocity.x = velocity.x.lerp(target_velocity, stats.acceleration * time.delta_seconds());
        } else {
            velocity.x = velocity.x.lerp(0.0, stats.deceleration * time.delta_seconds());
        }
    }
}
```

#### 2.3 åŸºæœ¬çš„ãªã‚¸ãƒ£ãƒ³ãƒ—
- [ ] ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ã®å‡¦ç†
- [ ] åœ°é¢åˆ¤å®šï¼ˆç°¡æ˜“ç‰ˆï¼‰
- [ ] ã‚¸ãƒ£ãƒ³ãƒ—åŠ›ã®é©ç”¨

```rust
#[derive(Component)]
pub struct GroundDetection {
    pub is_grounded: bool,
    pub ground_check_distance: f32,
}

fn player_jump(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Velocity, &GroundDetection, &PlayerStats)>,
) {
    for (mut velocity, ground, stats) in &mut query {
        if ground.is_grounded && keyboard.just_pressed(KeyCode::Space) {
            velocity.y = stats.jump_force;
        }
    }
}
```

#### 2.4 åŸºæœ¬çš„ãªè¡çªåˆ¤å®š
- [ ] Colliderã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] AABBè¡çªåˆ¤å®š
- [ ] åœ°é¢ã¨ã®è¡çªå‡¦ç†

```rust
#[derive(Component)]
pub struct Collider {
    pub size: Vec2,
    pub offset: Vec2,
}

#[derive(Component)]
pub struct Ground;

fn ground_collision(
    mut player_query: Query<(&mut Transform, &mut Velocity, &mut GroundDetection, &Collider), With<Player>>,
    ground_query: Query<(&Transform, &Collider), (With<Ground>, Without<Player>)>,
) {
    for (mut player_transform, mut velocity, mut ground_detection, player_collider) in &mut player_query {
        ground_detection.is_grounded = false;

        for (ground_transform, ground_collider) in &ground_query {
            // AABBè¡çªåˆ¤å®š
            let player_pos = player_transform.translation.truncate();
            let ground_pos = ground_transform.translation.truncate();

            // è¡çªã—ã¦ã„ãŸã‚‰æŠ¼ã—æˆ»ã™
            if check_aabb_collision(player_pos, player_collider, ground_pos, ground_collider) {
                // ä¸Šã‹ã‚‰è¡çªã—ãŸå ´åˆ
                if velocity.y < 0.0 {
                    player_transform.translation.y = ground_transform.translation.y
                        + ground_collider.size.y / 2.0
                        + player_collider.size.y / 2.0;
                    velocity.y = 0.0;
                    ground_detection.is_grounded = true;
                }
            }
        }
    }
}
```

#### 2.5 ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åè»¢
- [ ] å‘ãã«å¿œã˜ãŸã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåè»¢

```rust
fn flip_sprite_by_facing(
    mut query: Query<(&Player, &mut Sprite)>,
) {
    for (player, mut sprite) in &mut query {
        sprite.flip_x = !player.facing_right;
    }
}
```

### æˆæœç‰©
- ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã§ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’å·¦å³ã«å‹•ã‹ã›ã‚‹
- ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚¸ãƒ£ãƒ³ãƒ—ã§ãã‚‹
- åœ°é¢ã«ç€åœ°ã§ãã‚‹

---

## Phase 3: å…ˆé€²çš„ãªç§»å‹•ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ç›®æ¨™
ç¾ä»£çš„ãª2Dã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ã®"æ°—æŒã¡ã„ã„"å‹•ãã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 3.1 ã‚³ãƒ¨ãƒ¼ãƒ†ã‚¿ã‚¤ãƒ ï¼ˆCoyote Timeï¼‰
å´–ã‹ã‚‰è½ã¡ãŸç›´å¾Œã§ã‚‚ã‚¸ãƒ£ãƒ³ãƒ—å¯èƒ½ã«ã™ã‚‹

- [ ] ã‚³ãƒ¨ãƒ¼ãƒ†ã‚¿ã‚¤ãƒãƒ¼ã®å®Ÿè£…
- [ ] åœ°é¢ã‚’é›¢ã‚ŒãŸç¬é–“ã®æ¤œçŸ¥
- [ ] ã‚¿ã‚¤ãƒãƒ¼ä¸­ã®ã‚¸ãƒ£ãƒ³ãƒ—è¨±å¯

```rust
#[derive(Component)]
pub struct CoyoteTime {
    pub timer: Timer,
    pub was_grounded: bool,
}

fn update_coyote_time(
    time: Res<Time>,
    mut query: Query<(&GroundDetection, &mut CoyoteTime)>,
) {
    for (ground, mut coyote) in &mut query {
        if ground.is_grounded {
            coyote.timer.reset();
            coyote.was_grounded = true;
        } else if coyote.was_grounded {
            coyote.timer.tick(time.delta());
        }
    }
}

fn player_jump_with_coyote(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Velocity, &GroundDetection, &CoyoteTime, &PlayerStats)>,
) {
    for (mut velocity, ground, coyote, stats) in &mut query {
        let can_jump = ground.is_grounded || !coyote.timer.finished();

        if can_jump && keyboard.just_pressed(KeyCode::Space) {
            velocity.y = stats.jump_force;
        }
    }
}
```

#### 3.2 ã‚¸ãƒ£ãƒ³ãƒ—ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°
ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³ã‚’å°‘ã—æ—©ãæŠ¼ã—ã¦ã‚‚ã‚¸ãƒ£ãƒ³ãƒ—ãŒç™ºå‹•

- [ ] ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ã®å®Ÿè£…
- [ ] ãƒãƒƒãƒ•ã‚¡æ™‚é–“å†…ã®å…¥åŠ›è¨˜æ†¶
- [ ] ç€åœ°æ™‚ã®è‡ªå‹•ã‚¸ãƒ£ãƒ³ãƒ—

```rust
#[derive(Component)]
pub struct JumpBuffer {
    pub timer: Timer,
    pub buffered: bool,
}

fn buffer_jump_input(
    keyboard: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<&mut JumpBuffer>,
) {
    for mut buffer in &mut query {
        if keyboard.just_pressed(KeyCode::Space) {
            buffer.buffered = true;
            buffer.timer.reset();
        }

        if buffer.buffered {
            buffer.timer.tick(time.delta());
            if buffer.timer.finished() {
                buffer.buffered = false;
            }
        }
    }
}

fn consume_jump_buffer(
    mut query: Query<(&mut Velocity, &GroundDetection, &mut JumpBuffer, &PlayerStats)>,
) {
    for (mut velocity, ground, mut buffer, stats) in &mut query {
        if ground.is_grounded && buffer.buffered {
            velocity.y = stats.jump_force;
            buffer.buffered = false;
        }
    }
}
```

#### 3.3 å¯å¤‰ã‚¸ãƒ£ãƒ³ãƒ—é«˜ã•
ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ç¶šã‘ã‚‹æ™‚é–“ã§ã‚¸ãƒ£ãƒ³ãƒ—ã®é«˜ã•ãŒå¤‰ã‚ã‚‹

- [ ] ã‚¸ãƒ£ãƒ³ãƒ—ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚é–“ã®è¨ˆæ¸¬
- [ ] çŸ­æŠ¼ã—ã§ä½ã‚¸ãƒ£ãƒ³ãƒ—ã€é•·æŠ¼ã—ã§é«˜ã‚¸ãƒ£ãƒ³ãƒ—

```rust
#[derive(Component)]
pub struct VariableJump {
    pub min_jump_time: f32,
    pub max_jump_time: f32,
    pub jump_timer: f32,
    pub is_jumping: bool,
}

fn variable_jump_height(
    keyboard: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(&mut Velocity, &mut VariableJump)>,
) {
    for (mut velocity, mut jump) in &mut query {
        if jump.is_jumping {
            jump.jump_timer += time.delta_seconds();

            // ãƒœã‚¿ãƒ³ã‚’é›¢ã—ãŸã‚‰ä¸Šæ˜‡ã‚’å¼±ã‚ã‚‹
            if !keyboard.pressed(KeyCode::Space) {
                if jump.jump_timer < jump.min_jump_time {
                    velocity.y *= 0.5; // çŸ­æŠ¼ã—ã¯ä½ã‚¸ãƒ£ãƒ³ãƒ—
                }
                jump.is_jumping = false;
            }

            // æœ€å¤§æ™‚é–“ã‚’è¶…ãˆãŸã‚‰è‡ªå‹•ã§çµ‚äº†
            if jump.jump_timer >= jump.max_jump_time {
                jump.is_jumping = false;
            }
        }

        // ã‚¸ãƒ£ãƒ³ãƒ—é–‹å§‹æ™‚
        if keyboard.just_pressed(KeyCode::Space) {
            jump.is_jumping = true;
            jump.jump_timer = 0.0;
        }
    }
}
```

#### 3.4 å¤šæ®µã‚¸ãƒ£ãƒ³ãƒ—ï¼ˆãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—ï¼‰
- [ ] ã‚¸ãƒ£ãƒ³ãƒ—å›æ•°ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
- [ ] ç©ºä¸­ã§ã®è¿½åŠ ã‚¸ãƒ£ãƒ³ãƒ—
- [ ] ãƒªã‚»ãƒƒãƒˆå‡¦ç†

```rust
#[derive(Component)]
pub struct MultiJump {
    pub max_jumps: u8,
    pub current_jumps: u8,
}

fn multi_jump_system(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Velocity, &mut MultiJump, &GroundDetection, &PlayerStats)>,
) {
    for (mut velocity, mut multi_jump, ground, stats) in &mut query {
        // ç€åœ°æ™‚ã«ãƒªã‚»ãƒƒãƒˆ
        if ground.is_grounded {
            multi_jump.current_jumps = 0;
        }

        // ã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›
        if keyboard.just_pressed(KeyCode::Space) {
            if multi_jump.current_jumps < multi_jump.max_jumps {
                velocity.y = stats.jump_force;
                multi_jump.current_jumps += 1;
            }
        }
    }
}
```

#### 3.5 ãƒ€ãƒƒã‚·ãƒ¥/ãƒ­ãƒ¼ãƒ«
- [ ] ãƒ€ãƒƒã‚·ãƒ¥å…¥åŠ›ã®å‡¦ç†
- [ ] ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦ã®é©ç”¨
- [ ] ãƒ€ãƒƒã‚·ãƒ¥ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
- [ ] ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã®ç„¡æ•µæ™‚é–“ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰

```rust
#[derive(Component)]
pub struct Dash {
    pub speed: f32,
    pub duration: f32,
    pub cooldown: f32,
    pub timer: Timer,
    pub cooldown_timer: Timer,
    pub is_dashing: bool,
}

fn player_dash(
    keyboard: Res<ButtonInput<KeyCode>>,
    time: Res<Time>,
    mut query: Query<(&mut Velocity, &mut Dash, &Player)>,
) {
    for (mut velocity, mut dash, player) in &mut query {
        dash.timer.tick(time.delta());
        dash.cooldown_timer.tick(time.delta());

        // ãƒ€ãƒƒã‚·ãƒ¥ä¸­
        if dash.is_dashing {
            if dash.timer.finished() {
                dash.is_dashing = false;
            }
        }
        // ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹
        else if keyboard.just_pressed(KeyCode::ShiftLeft) && dash.cooldown_timer.finished() {
            dash.is_dashing = true;
            dash.timer.reset();
            dash.cooldown_timer.reset();

            let direction = if player.facing_right { 1.0 } else { -1.0 };
            velocity.x = dash.speed * direction;
        }
    }
}
```

#### 3.6 å£ã‚¸ãƒ£ãƒ³ãƒ—
- [ ] å£ã¨ã®æ¥è§¦åˆ¤å®š
- [ ] å£å¼µã‚Šä»˜ãçŠ¶æ…‹
- [ ] å£ã‹ã‚‰ã®ã‚¸ãƒ£ãƒ³ãƒ—

```rust
#[derive(Component)]
pub struct WallSlide {
    pub is_on_wall: bool,
    pub wall_on_right: bool,
    pub slide_speed: f32,
}

fn wall_detection(
    mut query: Query<(&Transform, &Collider, &mut WallSlide), With<Player>>,
    wall_query: Query<(&Transform, &Collider), With<Wall>>,
) {
    for (player_transform, player_collider, mut wall_slide) in &mut query {
        wall_slide.is_on_wall = false;

        // å£ã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆå·¦å³ã®ã¿ï¼‰
        for (wall_transform, wall_collider) in &wall_query {
            if check_wall_collision(player_transform, player_collider, wall_transform, wall_collider) {
                wall_slide.is_on_wall = true;
                wall_slide.wall_on_right = wall_transform.translation.x > player_transform.translation.x;
            }
        }
    }
}

fn wall_jump(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut query: Query<(&mut Velocity, &WallSlide, &PlayerStats)>,
) {
    for (mut velocity, wall_slide, stats) in &mut query {
        if wall_slide.is_on_wall && keyboard.just_pressed(KeyCode::Space) {
            // å£ã¨åå¯¾æ–¹å‘ã«ã‚¸ãƒ£ãƒ³ãƒ—
            let direction = if wall_slide.wall_on_right { -1.0 } else { 1.0 };
            velocity.x = stats.move_speed * direction * 1.2;
            velocity.y = stats.jump_force;
        }
    }
}
```

#### 3.7 å…¥åŠ›ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ±ç”¨ï¼‰
- [ ] å…¥åŠ›å±¥æ­´ã®è¨˜éŒ²
- [ ] ãƒãƒƒãƒ•ã‚¡æ™‚é–“ç®¡ç†
- [ ] è¤‡æ•°å…¥åŠ›ã®å¯¾å¿œ

```rust
#[derive(Resource)]
pub struct InputBuffer {
    pub buffer_time: f32,
    pub inputs: VecDeque<BufferedInput>,
}

pub struct BufferedInput {
    pub action: PlayerAction,
    pub timestamp: f32,
}

pub enum PlayerAction {
    Jump,
    Attack,
    Dash,
    Ability,
}
```

### æˆæœç‰©
- æ°—æŒã¡ã„ã„ç§»å‹•æ„Ÿè¦š
- ã‚³ãƒ¨ãƒ¼ãƒ†ã‚¿ã‚¤ãƒ /ã‚¸ãƒ£ãƒ³ãƒ—ãƒãƒƒãƒ•ã‚¡ã§è¨±å®¹åº¦ã®é«˜ã„æ“ä½œ
- ãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—ã€ãƒ€ãƒƒã‚·ãƒ¥ã€å£ã‚¸ãƒ£ãƒ³ãƒ—ãŒä½¿ãˆã‚‹

### å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹
- [Celeste Movement Analysis](https://www.youtube.com/watch?v=yorTG9at90g)
- [Game Feel: A Game Designer's Guide to Virtual Sensation](https://www.amazon.com/dp/0123743281)

---

## Phase 4: ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ç›®æ¨™
ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã€å‹•ãã«ç”Ÿå‘½æ„Ÿã‚’ä¸ãˆã‚‹

### ã‚¿ã‚¹ã‚¯

#### 4.1 ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
- [ ] ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ãƒ¼ãƒˆã®èª­ã¿è¾¼ã¿
- [ ] TextureAtlasã®ä½œæˆ
- [ ] ã‚¢ã‚»ãƒƒãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

```rust
#[derive(Resource)]
pub struct CharacterAssets {
    pub fox: Handle<TextureAtlasLayout>,
    pub fox_texture: Handle<Image>,
}

fn load_character_assets(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
    mut texture_atlas_layouts: ResMut<Assets<TextureAtlasLayout>>,
) {
    let fox_texture = asset_server.load("graphics/characters/players/fox/spritesheets/fox.png");

    let layout = TextureAtlasLayout::from_grid(
        UVec2::new(32, 32),  // ã‚¿ã‚¤ãƒ«ã‚µã‚¤ã‚º
        6,  // åˆ—æ•°
        10, // è¡Œæ•°
        None,
        None,
    );
    let fox_layout = texture_atlas_layouts.add(layout);

    commands.insert_resource(CharacterAssets {
        fox: fox_layout,
        fox_texture,
    });
}
```

#### 4.2 ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] AnimationControllerã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] AnimationStateã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] AnimationClipå®šç¾©

```rust
#[derive(Component)]
pub struct AnimationController {
    pub animations: HashMap<String, AnimationClip>,
    pub current_animation: String,
    pub previous_animation: String,
}

#[derive(Component)]
pub struct AnimationState {
    pub current_frame: usize,
    pub timer: Timer,
    pub playing: bool,
    pub looping: bool,
}

#[derive(Clone)]
pub struct AnimationClip {
    pub first_frame: usize,
    pub last_frame: usize,
    pub fps: f32,
}

impl AnimationController {
    pub fn play(&mut self, animation: &str, state: &mut AnimationState) {
        if let Some(clip) = self.animations.get(animation) {
            if self.current_animation != animation {
                self.previous_animation = self.current_animation.clone();
                self.current_animation = animation.to_string();
                state.current_frame = clip.first_frame;
                state.timer.reset();
            }
        }
    }
}
```

#### 4.3 ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ãƒ•ãƒ¬ãƒ¼ãƒ æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
- [ ] ãƒ«ãƒ¼ãƒ—å‡¦ç†
- [ ] TextureAtlasã®æ›´æ–°

```rust
fn update_animations(
    time: Res<Time>,
    mut query: Query<(
        &AnimationController,
        &mut AnimationState,
        &mut Sprite,
    )>,
) {
    for (controller, mut state, mut sprite) in &mut query {
        if !state.playing {
            continue;
        }

        state.timer.tick(time.delta());

        if state.timer.just_finished() {
            let clip = controller.animations.get(&controller.current_animation).unwrap();

            state.current_frame += 1;

            if state.current_frame > clip.last_frame {
                if state.looping {
                    state.current_frame = clip.first_frame;
                } else {
                    state.current_frame = clip.last_frame;
                    state.playing = false;
                }
            }

            if let Some(atlas) = &mut sprite.texture_atlas {
                atlas.index = state.current_frame;
            }
        }
    }
}
```

#### 4.4 çŠ¶æ…‹ã«å¿œã˜ãŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é·ç§»
- [ ] IdleçŠ¶æ…‹
- [ ] Walk/RunçŠ¶æ…‹
- [ ] JumpçŠ¶æ…‹ï¼ˆä¸Šæ˜‡/ä¸‹é™ï¼‰
- [ ] FallçŠ¶æ…‹
- [ ] LandçŠ¶æ…‹

```rust
fn player_animation_controller(
    mut query: Query<(
        &Velocity,
        &GroundDetection,
        &mut AnimationController,
        &mut AnimationState,
    ), With<Player>>,
) {
    for (velocity, ground, mut controller, mut state) in &mut query {
        let animation = if ground.is_grounded {
            if velocity.x.abs() > 10.0 {
                "run"
            } else {
                "idle"
            }
        } else {
            if velocity.y > 50.0 {
                "jump"
            } else {
                "fall"
            }
        };

        controller.play(animation, &mut state);
    }
}
```

#### 4.5 ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
- [ ] ç‰¹å®šãƒ•ãƒ¬ãƒ¼ãƒ ã§ã®ã‚¤ãƒ™ãƒ³ãƒˆç™ºç«
- [ ] è¶³éŸ³ã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒˆãƒªã‚¬ãƒ¼

```rust
#[derive(Component)]
pub struct AnimationEvents {
    pub events: HashMap<usize, Vec<AnimationEvent>>,
}

pub enum AnimationEvent {
    PlaySound(String),
    SpawnEffect(String),
    TriggerCallback(fn()),
}

fn process_animation_events(
    mut query: Query<(&AnimationState, &AnimationEvents)>,
    mut commands: Commands,
) {
    for (state, events) in &mut query {
        if let Some(frame_events) = events.events.get(&state.current_frame) {
            for event in frame_events {
                match event {
                    AnimationEvent::PlaySound(sound) => {
                        // éŸ³ã‚’é³´ã‚‰ã™
                    }
                    AnimationEvent::SpawnEffect(effect) => {
                        // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
                    }
                    AnimationEvent::TriggerCallback(callback) => {
                        callback();
                    }
                }
            }
        }
    }
}
```

#### 4.6 RONã‹ã‚‰ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³èª­ã¿è¾¼ã¿
- [ ] RONè¨­å®šã®æ§‹é€ ä½“
- [ ] ãƒ‘ãƒ¼ã‚¹å‡¦ç†
- [ ] AnimationControllerã¸ã®å¤‰æ›

```rust
use serde::Deserialize;

#[derive(Deserialize)]
pub struct AnimationConfigRon {
    pub spritesheet_path: String,
    pub sprite_size: (f32, f32),
    pub columns: usize,
    pub rows: usize,
    pub clips: HashMap<String, AnimationClipRon>,
    pub default_animation: String,
}

#[derive(Deserialize)]
pub struct AnimationClipRon {
    pub first: usize,
    pub last: usize,
    pub fps: f32,
}

impl From<AnimationConfigRon> for AnimationController {
    fn from(config: AnimationConfigRon) -> Self {
        let mut animations = HashMap::new();

        for (name, clip_ron) in config.clips {
            animations.insert(name, AnimationClip {
                first_frame: clip_ron.first,
                last_frame: clip_ron.last,
                fps: clip_ron.fps,
            });
        }

        AnimationController {
            animations,
            current_animation: config.default_animation.clone(),
            previous_animation: String::new(),
        }
    }
}
```

### æˆæœç‰©
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹•ãã«å¿œã˜ãŸã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- RONãƒ•ã‚¡ã‚¤ãƒ«ã§ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³è¨­å®šãŒç®¡ç†ã§ãã‚‹

---

## Phase 5: æˆ¦é—˜åŸºç¤ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ç›®æ¨™
åŸºæœ¬çš„ãªæ”»æ’ƒã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 5.1 ä½“åŠ›ã‚·ã‚¹ãƒ†ãƒ 
- [ ] Healthã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†
- [ ] æ­»äº¡åˆ¤å®š

```rust
#[derive(Component)]
pub struct Health {
    pub current: f32,
    pub max: f32,
}

#[derive(Event)]
pub struct DamageEvent {
    pub target: Entity,
    pub amount: f32,
    pub source: DamageSource,
    pub knockback: Vec2,
}

pub enum DamageSource {
    Enemy(Entity),
    Hazard,
    Projectile(Entity),
}

fn apply_damage(
    mut events: EventReader<DamageEvent>,
    mut query: Query<&mut Health>,
    mut death_events: EventWriter<DeathEvent>,
) {
    for event in events.read() {
        if let Ok(mut health) = query.get_mut(event.target) {
            health.current -= event.amount;

            if health.current <= 0.0 {
                death_events.send(DeathEvent {
                    entity: event.target,
                });
            }
        }
    }
}
```

#### 5.2 åŸºæœ¬çš„ãªæ”»æ’ƒ
- [ ] æ”»æ’ƒå…¥åŠ›ã®å‡¦ç†
- [ ] æ”»æ’ƒåˆ¤å®šã®ç”Ÿæˆ
- [ ] ãƒ’ãƒƒãƒˆãƒœãƒƒã‚¯ã‚¹/ãƒãƒ¼ãƒˆãƒœãƒƒã‚¯ã‚¹

```rust
#[derive(Component)]
pub struct Attack {
    pub damage: f32,
    pub active: bool,
    pub duration: Timer,
    pub hitbox: Collider,
}

#[derive(Component)]
pub struct Hitbox {
    pub damage: f32,
    pub knockback: Vec2,
    pub hit_entities: HashSet<Entity>,  // åŒã˜æ•µã‚’è¤‡æ•°å›ãƒ’ãƒƒãƒˆã•ã›ãªã„
}

fn player_attack(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut commands: Commands,
    query: Query<(Entity, &Transform, &Player), With<Player>>,
) {
    for (entity, transform, player) in &query {
        if keyboard.just_pressed(KeyCode::KeyX) {
            // æ”»æ’ƒåˆ¤å®šã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ç”Ÿæˆ
            let offset = if player.facing_right { 20.0 } else { -20.0 };

            commands.spawn((
                Hitbox {
                    damage: 10.0,
                    knockback: Vec2::new(offset * 5.0, 100.0),
                    hit_entities: HashSet::new(),
                },
                Collider {
                    size: Vec2::new(30.0, 30.0),
                    offset: Vec2::new(offset, 0.0),
                },
                Transform::from_translation(transform.translation),
                AttackLifetime(Timer::from_seconds(0.2, TimerMode::Once)),
            ));
        }
    }
}

#[derive(Component)]
pub struct AttackLifetime(Timer);

fn despawn_expired_attacks(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut AttackLifetime)>,
) {
    for (entity, mut lifetime) in &mut query {
        lifetime.0.tick(time.delta());
        if lifetime.0.finished() {
            commands.entity(entity).despawn();
        }
    }
}
```

#### 5.3 ãƒ’ãƒƒãƒˆæ¤œå‡º
- [ ] æ”»æ’ƒåˆ¤å®šã¨æ•µã®è¡çªæ¤œå‡º
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆã®ç™ºç«
- [ ] é‡è¤‡ãƒ’ãƒƒãƒˆã®é˜²æ­¢

```rust
fn detect_hits(
    mut hitbox_query: Query<(&Transform, &Collider, &mut Hitbox)>,
    target_query: Query<(Entity, &Transform, &Collider), With<Enemy>>,
    mut damage_events: EventWriter<DamageEvent>,
) {
    for (hitbox_transform, hitbox_collider, mut hitbox) in &mut hitbox_query {
        for (enemy_entity, enemy_transform, enemy_collider) in &target_query {
            // æ—¢ã«ãƒ’ãƒƒãƒˆã—ã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            if hitbox.hit_entities.contains(&enemy_entity) {
                continue;
            }

            if check_collision(hitbox_transform, hitbox_collider, enemy_transform, enemy_collider) {
                damage_events.send(DamageEvent {
                    target: enemy_entity,
                    amount: hitbox.damage,
                    source: DamageSource::Player,
                    knockback: hitbox.knockback,
                });

                hitbox.hit_entities.insert(enemy_entity);
            }
        }
    }
}
```

#### 5.4 ãƒãƒƒã‚¯ãƒãƒƒã‚¯
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®å¹ãé£›ã³
- [ ] ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ–¹å‘ã®è¨ˆç®—
- [ ] ãƒãƒƒã‚¯ãƒãƒƒã‚¯ä¸­ã®åˆ¶å¾¡ä¸èƒ½

```rust
#[derive(Component)]
pub struct Knockback {
    pub velocity: Vec2,
    pub duration: Timer,
    pub active: bool,
}

fn apply_knockback_from_damage(
    mut events: EventReader<DamageEvent>,
    mut query: Query<&mut Knockback>,
) {
    for event in events.read() {
        if let Ok(mut knockback) = query.get_mut(event.target) {
            knockback.velocity = event.knockback;
            knockback.active = true;
            knockback.duration.reset();
        }
    }
}

fn update_knockback(
    time: Res<Time>,
    mut query: Query<(&mut Velocity, &mut Knockback)>,
) {
    for (mut velocity, mut knockback) in &mut query {
        if knockback.active {
            knockback.duration.tick(time.delta());

            // ãƒãƒƒã‚¯ãƒãƒƒã‚¯é€Ÿåº¦ã‚’é©ç”¨
            velocity.x = knockback.velocity.x;
            velocity.y = knockback.velocity.y;

            // æ¸›è¡°
            knockback.velocity *= 0.9;

            if knockback.duration.finished() {
                knockback.active = false;
            }
        }
    }
}
```

#### 5.5 ç„¡æ•µæ™‚é–“
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸å¾Œã®ä¸€æ™‚çš„ç„¡æ•µ
- [ ] ç„¡æ•µä¸­ã®ç‚¹æ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸ç„¡åŠ¹åŒ–

```rust
#[derive(Component)]
pub struct Invincibility {
    pub timer: Timer,
    pub active: bool,
    pub blink_interval: f32,
    pub blink_timer: f32,
}

fn start_invincibility_on_damage(
    mut events: EventReader<DamageEvent>,
    mut query: Query<&mut Invincibility>,
) {
    for event in events.read() {
        if let Ok(mut invincibility) = query.get_mut(event.target) {
            invincibility.active = true;
            invincibility.timer.reset();
        }
    }
}

fn update_invincibility(
    time: Res<Time>,
    mut query: Query<(&mut Invincibility, &mut Visibility)>,
) {
    for (mut invincibility, mut visibility) in &mut query {
        if invincibility.active {
            invincibility.timer.tick(time.delta());
            invincibility.blink_timer += time.delta_seconds();

            // ç‚¹æ»…
            if invincibility.blink_timer >= invincibility.blink_interval {
                *visibility = match *visibility {
                    Visibility::Visible => Visibility::Hidden,
                    _ => Visibility::Visible,
                };
                invincibility.blink_timer = 0.0;
            }

            if invincibility.timer.finished() {
                invincibility.active = false;
                *visibility = Visibility::Visible;
            }
        }
    }
}

fn ignore_damage_when_invincible(
    mut events: EventReader<DamageEvent>,
    query: Query<&Invincibility>,
    mut filtered_events: EventWriter<DamageEvent>,
) {
    for event in events.read() {
        if let Ok(invincibility) = query.get(event.target) {
            if !invincibility.active {
                filtered_events.send(event.clone());
            }
        }
    }
}
```

#### 5.6 æ­»äº¡å‡¦ç†
- [ ] æ­»äº¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- [ ] ãƒªã‚¹ãƒãƒ¼ãƒ³
- [ ] ãƒ©ã‚¤ãƒ•ã‚·ã‚¹ãƒ†ãƒ 

```rust
#[derive(Event)]
pub struct DeathEvent {
    pub entity: Entity,
}

#[derive(Component)]
pub struct Lives {
    pub count: u8,
}

fn handle_player_death(
    mut events: EventReader<DeathEvent>,
    mut query: Query<(&mut Lives, &mut Transform, &mut Health), With<Player>>,
    mut game_state: ResMut<NextState<GameState>>,
) {
    for event in events.read() {
        if let Ok((mut lives, mut transform, mut health)) = query.get_mut(event.entity) {
            lives.count = lives.count.saturating_sub(1);

            if lives.count > 0 {
                // ãƒªã‚¹ãƒãƒ¼ãƒ³
                transform.translation = Vec3::new(0.0, 0.0, 0.0); // ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä½ç½®
                health.current = health.max;
            } else {
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                game_state.set(GameState::GameOver);
            }
        }
    }
}
```

### æˆæœç‰©
- æ”»æ’ƒãƒœã‚¿ãƒ³ã§æ•µã‚’æ”»æ’ƒã§ãã‚‹
- ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã‚‹ã¨ãƒãƒƒã‚¯ãƒãƒƒã‚¯ã¨ç„¡æ•µæ™‚é–“ãŒç™ºç”Ÿ
- ä½“åŠ›ãŒã‚¼ãƒ­ã«ãªã‚‹ã¨æ­»äº¡å‡¦ç†

---

## Phase 6: æ•µã‚·ã‚¹ãƒ†ãƒ Iï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ç›®æ¨™
åŸºæœ¬çš„ãªæ•µAIã¨ã‚¹ãƒãƒ¼ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 6.1 æ•µã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®ã‚¹ãƒãƒ¼ãƒ³
- [ ] Enemyã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- [ ] RONè¨­å®šã‹ã‚‰ã®èª­ã¿è¾¼ã¿
- [ ] ã‚¹ãƒãƒ¼ãƒ³ã‚·ã‚¹ãƒ†ãƒ 

```rust
#[derive(Component)]
pub struct Enemy {
    pub enemy_type: String,
}

#[derive(Component)]
pub struct EnemyStats {
    pub move_speed: f32,
    pub damage: f32,
    pub score_value: u32,
}

fn spawn_enemy(
    commands: &mut Commands,
    enemy_type: &str,
    position: Vec2,
    configs: &GameConfigs,
    assets: &GameAssets,
) {
    let config = configs.enemies.get(enemy_type).unwrap();

    commands.spawn((
        Enemy {
            enemy_type: enemy_type.to_string(),
        },
        EnemyStats {
            move_speed: config.stats.move_speed,
            damage: config.stats.damage,
            score_value: config.stats.score_value,
        },
        Health {
            current: config.health.max,
            max: config.health.max,
        },
        Velocity { x: 0.0, y: 0.0 },
        Collider {
            size: config.collider.size,
            offset: config.collider.offset,
        },
        Transform::from_translation(position.extend(0.0)),
        // ... ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆç­‰
    ));
}
```

#### 6.2 åŸºæœ¬çš„ãªAI - Patrolï¼ˆå·¡å›ï¼‰
- [ ] å·¡å›ãƒã‚¤ãƒ³ãƒˆã®è¨­å®š
- [ ] ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯
- [ ] æ–¹å‘è»¢æ›

```rust
#[derive(Component)]
pub struct PatrolAI {
    pub patrol_points: Vec<Vec2>,
    pub current_point_index: usize,
    pub wait_time: f32,
    pub wait_timer: f32,
}

fn patrol_ai_system(
    time: Res<Time>,
    mut query: Query<(&mut Transform, &mut Velocity, &mut PatrolAI, &EnemyStats)>,
) {
    for (mut transform, mut velocity, mut patrol, stats) in &mut query {
        let current_pos = transform.translation.truncate();
        let target_pos = patrol.patrol_points[patrol.current_point_index];
        let distance = current_pos.distance(target_pos);

        if distance < 5.0 {
            // ç›®æ¨™åœ°ç‚¹ã«åˆ°é”
            if patrol.wait_timer >= patrol.wait_time {
                // æ¬¡ã®ãƒã‚¤ãƒ³ãƒˆã¸
                patrol.current_point_index = (patrol.current_point_index + 1) % patrol.patrol_points.len();
                patrol.wait_timer = 0.0;
            } else {
                patrol.wait_timer += time.delta_seconds();
                velocity.x = 0.0;
            }
        } else {
            // ç§»å‹•
            let direction = (target_pos - current_pos).normalize();
            velocity.x = direction.x * stats.move_speed;
        }
    }
}
```

#### 6.3 Chase AIï¼ˆè¿½è·¡ï¼‰
- [ ] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¤œçŸ¥
- [ ] è¿½è·¡ãƒ­ã‚¸ãƒƒã‚¯
- [ ] è¦–ç•Œç¯„å›²

```rust
#[derive(Component)]
pub struct ChaseAI {
    pub detection_range: f32,
    pub attack_range: f32,
    pub is_chasing: bool,
}

fn chase_ai_system(
    mut enemy_query: Query<(&Transform, &mut Velocity, &mut ChaseAI, &EnemyStats), With<Enemy>>,
    player_query: Query<&Transform, With<Player>>,
) {
    if let Ok(player_transform) = player_query.get_single() {
        let player_pos = player_transform.translation.truncate();

        for (enemy_transform, mut velocity, mut chase, stats) in &mut enemy_query {
            let enemy_pos = enemy_transform.translation.truncate();
            let distance = enemy_pos.distance(player_pos);

            if distance < chase.detection_range {
                chase.is_chasing = true;

                if distance > chase.attack_range {
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
                    let direction = (player_pos - enemy_pos).normalize();
                    velocity.x = direction.x * stats.move_speed;
                } else {
                    // æ”»æ’ƒç¯„å›²å†…ã§ã¯åœæ­¢
                    velocity.x = 0.0;
                }
            } else {
                chase.is_chasing = false;
                velocity.x = 0.0;
            }
        }
    }
}
```

#### 6.4 Flying AIï¼ˆé£›è¡Œãƒ‘ã‚¿ãƒ¼ãƒ³ï¼‰
- [ ] ã‚µã‚¤ãƒ³ã‚«ãƒ¼ãƒ–ç§»å‹•
- [ ] å††é‹å‹•
- [ ] ãƒ›ãƒãƒªãƒ³ã‚°

```rust
#[derive(Component)]
pub struct FlyingAI {
    pub pattern: FlyingPattern,
    pub time: f32,
    pub origin: Vec2,
}

pub enum FlyingPattern {
    SineWave { amplitude: f32, frequency: f32 },
    Circle { radius: f32, speed: f32 },
    Hover { range: f32, speed: f32 },
}

fn flying_ai_system(
    time: Res<Time>,
    mut query: Query<(&mut Transform, &mut FlyingAI, &EnemyStats)>,
) {
    for (mut transform, mut flying, stats) in &mut query {
        flying.time += time.delta_seconds();

        match &flying.pattern {
            FlyingPattern::SineWave { amplitude, frequency } => {
                let x = flying.origin.x + flying.time * stats.move_speed;
                let y = flying.origin.y + (flying.time * frequency).sin() * amplitude;
                transform.translation = Vec3::new(x, y, 0.0);
            }
            FlyingPattern::Circle { radius, speed } => {
                let angle = flying.time * speed;
                let x = flying.origin.x + angle.cos() * radius;
                let y = flying.origin.y + angle.sin() * radius;
                transform.translation = Vec3::new(x, y, 0.0);
            }
            FlyingPattern::Hover { range, speed } => {
                let offset = (flying.time * speed).sin() * range;
                transform.translation.y = flying.origin.y + offset;
            }
        }
    }
}
```

#### 6.5 æ•µã®æ”»æ’ƒ
- [ ] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®æ¥è§¦ãƒ€ãƒ¡ãƒ¼ã‚¸
- [ ] å¼¾ç™ºå°„ï¼ˆé£›ã³é“å…·ï¼‰

```rust
#[derive(Component)]
pub struct ContactDamage {
    pub damage: f32,
    pub knockback_force: f32,
}

fn enemy_contact_damage(
    enemy_query: Query<(&Transform, &Collider, &ContactDamage), With<Enemy>>,
    player_query: Query<(Entity, &Transform, &Collider), With<Player>>,
    mut damage_events: EventWriter<DamageEvent>,
) {
    for (player_entity, player_transform, player_collider) in &player_query {
        for (enemy_transform, enemy_collider, contact) in &enemy_query {
            if check_collision(player_transform, player_collider, enemy_transform, enemy_collider) {
                let direction = (player_transform.translation - enemy_transform.translation).normalize();
                let knockback = direction.truncate() * contact.knockback_force;

                damage_events.send(DamageEvent {
                    target: player_entity,
                    amount: contact.damage,
                    source: DamageSource::Enemy(player_entity),
                    knockback,
                });
            }
        }
    }
}
```

#### 6.6 æ•µã®æ­»äº¡å‡¦ç†
- [ ] æ­»äº¡ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- [ ] ã‚¹ã‚³ã‚¢åŠ ç®—
- [ ] ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 

```rust
fn handle_enemy_death(
    mut commands: Commands,
    mut events: EventReader<DeathEvent>,
    query: Query<(&Transform, &EnemyStats), With<Enemy>>,
    mut score: ResMut<Score>,
) {
    for event in events.read() {
        if let Ok((transform, stats)) = query.get(event.entity) {
            // ã‚¹ã‚³ã‚¢åŠ ç®—
            score.value += stats.score_value;

            // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆ
            spawn_death_effect(&mut commands, transform.translation.truncate());

            // ãƒ‰ãƒ­ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆç¢ºç‡ï¼‰
            if rand::random::<f32>() < 0.3 {
                spawn_collectible(&mut commands, transform.translation.truncate());
            }

            // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‰Šé™¤
            commands.entity(event.entity).despawn_recursive();
        }
    }
}
```

### æˆæœç‰©
- 3ç¨®é¡ã®AIï¼ˆå·¡å›ã€è¿½è·¡ã€é£›è¡Œï¼‰ã‚’æŒã¤æ•µ
- æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ”»æ’ƒ
- æ•µã‚’å€’ã™ã¨ã‚¹ã‚³ã‚¢ãŒå…¥ã‚‹

---

## Phase 7: ãƒ¬ãƒ™ãƒ«ã‚·ã‚¹ãƒ†ãƒ åŸºç¤ï¼ˆäºˆæƒ³æ™‚é–“: 5-6æ—¥ï¼‰

### ç›®æ¨™
ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ—ãƒ™ãƒ¼ã‚¹ã®ãƒ¬ãƒ™ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰

### ã‚¿ã‚¹ã‚¯

#### 7.1 bevy_ecs_tilemapã®å°å…¥
- [ ] Cargo.tomlã«è¿½åŠ 
- [ ] åŸºæœ¬çš„ãªã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ—ã®è¡¨ç¤º

```toml
[dependencies]
bevy_ecs_tilemap = "0.15"
```

```rust
use bevy_ecs_tilemap::prelude::*;

fn setup_tilemap(
    mut commands: Commands,
    asset_server: Res<AssetServer>,
) {
    let texture_handle = asset_server.load("graphics/environments/sunny_land/tilesets/tileset.png");

    let map_size = TilemapSize { x: 32, y: 18 };
    let tile_size = TilemapTileSize { x: 16.0, y: 16.0 };
    let grid_size = tile_size.into();
    let map_type = TilemapType::default();

    let mut tile_storage = TileStorage::empty(map_size);
    let tilemap_entity = commands.spawn_empty().id();

    // ã‚¿ã‚¤ãƒ«ã‚’é…ç½®
    for x in 0..map_size.x {
        for y in 0..map_size.y {
            let tile_pos = TilePos { x, y };
            let tile_entity = commands
                .spawn(TileBundle {
                    position: tile_pos,
                    tilemap_id: TilemapId(tilemap_entity),
                    texture_index: TileTextureIndex(0), // ã‚¿ã‚¤ãƒ«ç•ªå·
                    ..Default::default()
                })
                .id();
            tile_storage.set(&tile_pos, tile_entity);
        }
    }

    commands.entity(tilemap_entity).insert(TilemapBundle {
        grid_size,
        map_type,
        size: map_size,
        storage: tile_storage,
        texture: TilemapTexture::Single(texture_handle),
        tile_size,
        transform: Transform::from_translation(Vec3::ZERO),
        ..Default::default()
    });
}
```

#### 7.2 ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ã®RONåŒ–
- [ ] ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®è¨­è¨ˆ
- [ ] RONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ã®èª­ã¿è¾¼ã¿
- [ ] ã‚¿ã‚¤ãƒ«ã®ç¨®é¡ï¼ˆåœ°é¢ã€å£ã€ç©ºï¼‰

```ron
// assets/config/levels/stage_1_1.ron
(
    name: "Forest Path",
    width: 32,
    height: 18,

    // ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ï¼ˆ2Dé…åˆ—ï¼‰
    tiles: [
        [0, 0, 0, 0, 0, 0, 0, 0, ...],  // ä¸€ç•ªä¸Šã®è¡Œ
        [0, 0, 0, 0, 0, 0, 0, 0, ...],
        // ... 18è¡Œ
    ],

    // ã‚¿ã‚¤ãƒ«ã®è¡çªæƒ…å ±
    collision_tiles: [1, 2, 3, 5, 6],  // ã“ã‚Œã‚‰ã®ã‚¿ã‚¤ãƒ«ç•ªå·ã¯è¡çªåˆ¤å®šã‚ã‚Š

    // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£é…ç½®
    entities: [
        (type: "enemy_bat", position: (x: 300.0, y: 150.0)),
        (type: "collectible_cherry", position: (x: 200.0, y: 180.0)),
    ],
)
```

#### 7.3 ã‚¿ã‚¤ãƒ«ã¨ã®è¡çªåˆ¤å®š
- [ ] ã‚¿ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹ã®è¡çªåˆ¤å®š
- [ ] åœ°é¢åˆ¤å®šã®æ”¹è‰¯
- [ ] å£ã¨ã®è¡çª

```rust
#[derive(Component)]
pub struct TileCollider;

fn tilemap_collision(
    mut player_query: Query<(&mut Transform, &mut Velocity, &Collider), With<Player>>,
    tilemap_query: Query<(&TileStorage, &TilemapSize, &TilemapGridSize, &TilemapType)>,
    tile_query: Query<&TilePos, With<TileCollider>>,
) {
    for (mut transform, mut velocity, collider) in &mut player_query {
        for (tile_storage, map_size, grid_size, map_type) in &tilemap_query {
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒé‡ãªã£ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã‚’å–å¾—
            let player_pos = transform.translation.truncate();

            // å‘¨å›²ã®ã‚¿ã‚¤ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
            let check_tiles = get_surrounding_tiles(player_pos, grid_size);

            for tile_pos in check_tiles {
                if let Some(tile_entity) = tile_storage.get(&tile_pos) {
                    if tile_query.contains(tile_entity) {
                        // è¡çªå‡¦ç†
                        resolve_tile_collision(&mut transform, &mut velocity, collider, &tile_pos, grid_size);
                    }
                }
            }
        }
    }
}
```

#### 7.4 èƒŒæ™¯ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆè¦–å·®åŠ¹æœï¼‰
- [ ] è¤‡æ•°ã®èƒŒæ™¯ãƒ¬ã‚¤ãƒ¤ãƒ¼
- [ ] è¦–å·®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
- [ ] æ·±åº¦ç®¡ç†

```rust
#[derive(Component)]
pub struct ParallaxLayer {
    pub speed: f32,
    pub depth: f32,
}

fn parallax_background(
    camera_query: Query<&Transform, With<Camera>>,
    mut background_query: Query<(&mut Transform, &ParallaxLayer), Without<Camera>>,
) {
    if let Ok(camera_transform) = camera_query.get_single() {
        let camera_pos = camera_transform.translation.truncate();

        for (mut bg_transform, parallax) in &mut background_query {
            // ã‚«ãƒ¡ãƒ©ç§»å‹•é‡ã«è¦–å·®é€Ÿåº¦ã‚’æ›ã‘ã‚‹
            bg_transform.translation.x = -camera_pos.x * parallax.speed;
            bg_transform.translation.y = -camera_pos.y * parallax.speed * 0.5; // Yæ–¹å‘ã¯åŠåˆ†
            bg_transform.translation.z = parallax.depth;
        }
    }
}
```

#### 7.5 ã‚´ãƒ¼ãƒ«/ã‚¯ãƒªã‚¢åˆ¤å®š
- [ ] ã‚´ãƒ¼ãƒ«åœ°ç‚¹ã®é…ç½®
- [ ] ã‚´ãƒ¼ãƒ«åˆ°é”ã®æ¤œçŸ¥
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢å‡¦ç†

```rust
#[derive(Component)]
pub struct Goal;

fn check_goal_reached(
    player_query: Query<(&Transform, &Collider), With<Player>>,
    goal_query: Query<(&Transform, &Collider), With<Goal>>,
    mut stage_events: EventWriter<StageCompleteEvent>,
) {
    for (player_transform, player_collider) in &player_query {
        for (goal_transform, goal_collider) in &goal_query {
            if check_collision(player_transform, player_collider, goal_transform, goal_collider) {
                stage_events.send(StageCompleteEvent);
            }
        }
    }
}
```

#### 7.6 ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ
- [ ] ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆé…ç½®
- [ ] é€šéæ™‚ã®ã‚»ãƒ¼ãƒ–
- [ ] ãƒªã‚¹ãƒãƒ¼ãƒ³ä½ç½®ã®æ›´æ–°

```rust
#[derive(Component)]
pub struct Checkpoint {
    pub activated: bool,
}

#[derive(Resource)]
pub struct RespawnPoint(pub Vec2);

fn checkpoint_system(
    mut player_query: Query<&Transform, With<Player>>,
    mut checkpoint_query: Query<(&Transform, &mut Checkpoint)>,
    mut respawn_point: ResMut<RespawnPoint>,
) {
    let player_pos = player_query.single().translation.truncate();

    for (checkpoint_transform, mut checkpoint) in &mut checkpoint_query {
        if checkpoint.activated {
            continue;
        }

        let checkpoint_pos = checkpoint_transform.translation.truncate();
        if player_pos.distance(checkpoint_pos) < 30.0 {
            checkpoint.activated = true;
            respawn_point.0 = checkpoint_pos;
            // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ/ã‚µã‚¦ãƒ³ãƒ‰å†ç”Ÿ
        }
    }
}
```

### æˆæœç‰©
- ã‚¿ã‚¤ãƒ«ãƒãƒƒãƒ—ã§æ§‹ç¯‰ã•ã‚ŒãŸã‚¹ãƒ†ãƒ¼ã‚¸
- è¦–å·®åŠ¹æœã®ã‚ã‚‹èƒŒæ™¯
- ã‚´ãƒ¼ãƒ«ã¨ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ

### å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹
- [bevy_ecs_tilemap ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://github.com/StarArawn/bevy_ecs_tilemap)

---

## Phase 8: ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ Iï¼ˆäºˆæƒ³æ™‚é–“: 2-3æ—¥ï¼‰

### ç›®æ¨™
æ°—æŒã¡ã„ã„ã‚«ãƒ¡ãƒ©ãƒ¯ãƒ¼ã‚¯ã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 8.1 ã‚¹ãƒ ãƒ¼ã‚ºãªãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¿½å¾“
- [ ] Lerpã«ã‚ˆã‚‹æ»‘ã‚‰ã‹ãªè¿½å¾“
- [ ] ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³ï¼ˆä¸­å¤®ä»˜è¿‘ã§ã¯å‹•ã‹ãªã„ï¼‰

```rust
#[derive(Component)]
pub struct CameraFollow {
    pub target: Entity,
    pub smoothness: f32,
    pub dead_zone: Rect,
}

fn camera_follow_system(
    time: Res<Time>,
    target_query: Query<&Transform, With<Player>>,
    mut camera_query: Query<(&mut Transform, &CameraFollow), Without<Player>>,
) {
    for (mut camera_transform, follow) in &mut camera_query {
        if let Ok(target_transform) = target_query.get(follow.target) {
            let target_pos = target_transform.translation.truncate();
            let camera_pos = camera_transform.translation.truncate();

            // ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³å¤–ãªã‚‰è¿½å¾“
            let offset = target_pos - camera_pos;

            let should_move_x = offset.x.abs() > follow.dead_zone.width() / 2.0;
            let should_move_y = offset.y.abs() > follow.dead_zone.height() / 2.0;

            let mut new_pos = camera_pos;

            if should_move_x {
                new_pos.x = new_pos.x.lerp(target_pos.x, follow.smoothness * time.delta_seconds());
            }
            if should_move_y {
                new_pos.y = new_pos.y.lerp(target_pos.y, follow.smoothness * time.delta_seconds());
            }

            camera_transform.translation = new_pos.extend(camera_transform.translation.z);
        }
    }
}
```

#### 8.2 ã‚«ãƒ¡ãƒ©å¢ƒç•Œ
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¸ã®ç«¯ã§ã‚«ãƒ¡ãƒ©ã‚’æ­¢ã‚ã‚‹
- [ ] æœ€å°/æœ€å¤§åº§æ¨™ã®è¨­å®š

```rust
#[derive(Component)]
pub struct CameraBounds {
    pub min: Vec2,
    pub max: Vec2,
}

fn apply_camera_bounds(
    mut camera_query: Query<(&mut Transform, &CameraBounds), With<Camera>>,
) {
    for (mut transform, bounds) in &mut camera_query {
        transform.translation.x = transform.translation.x.clamp(bounds.min.x, bounds.max.x);
        transform.translation.y = transform.translation.y.clamp(bounds.min.y, bounds.max.y);
    }
}
```

#### 8.3 ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®ã‚·ã‚§ã‚¤ã‚¯
- [ ] ãƒ©ãƒ³ãƒ€ãƒ ãªã‚ªãƒ•ã‚»ãƒƒãƒˆ
- [ ] æ¸›è¡°

```rust
#[derive(Component)]
pub struct CameraShake {
    pub intensity: f32,
    pub duration: Timer,
    pub active: bool,
}

fn camera_shake_system(
    time: Res<Time>,
    mut query: Query<(&mut Transform, &mut CameraShake), With<Camera>>,
) {
    for (mut transform, mut shake) in &mut query {
        if shake.active {
            shake.duration.tick(time.delta());

            if shake.duration.finished() {
                shake.active = false;
            } else {
                // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚ªãƒ•ã‚»ãƒƒãƒˆ
                let progress = shake.duration.fraction();
                let current_intensity = shake.intensity * (1.0 - progress); // æ¸›è¡°

                let offset_x = (rand::random::<f32>() - 0.5) * 2.0 * current_intensity;
                let offset_y = (rand::random::<f32>() - 0.5) * 2.0 * current_intensity;

                transform.translation.x += offset_x;
                transform.translation.y += offset_y;
            }
        }
    }
}

// ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¤ãƒ™ãƒ³ãƒˆã§ã‚·ã‚§ã‚¤ã‚¯ã‚’é–‹å§‹
fn trigger_shake_on_damage(
    mut events: EventReader<DamageEvent>,
    mut camera_query: Query<&mut CameraShake, With<Camera>>,
) {
    for _event in events.read() {
        if let Ok(mut shake) = camera_query.get_single_mut() {
            shake.active = true;
            shake.intensity = 10.0;
            shake.duration.reset();
        }
    }
}
```

#### 8.4 ãƒ”ã‚¯ã‚»ãƒ«ãƒ‘ãƒ¼ãƒ•ã‚§ã‚¯ãƒˆè¨­å®š
- [ ] å†…éƒ¨è§£åƒåº¦ã®è¨­å®š
- [ ] æ‹¡å¤§æ™‚ã®ãƒ”ã‚¯ã‚»ãƒ«ã‚¢ãƒ¼ãƒˆç¶­æŒ

```rust
fn setup_pixel_perfect_camera(
    mut commands: Commands,
) {
    // å†…éƒ¨è§£åƒåº¦320x180ã‚’1280x720ã«æ‹¡å¤§
    commands.spawn((
        Camera2dBundle {
            projection: OrthographicProjection {
                scaling_mode: ScalingMode::WindowSize(4.0), // 4å€ã‚¹ã‚±ãƒ¼ãƒ«
                ..default()
            },
            ..default()
        },
        CameraFollow {
            target: Entity::PLACEHOLDER, // å¾Œã§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’è¨­å®š
            smoothness: 5.0,
            dead_zone: Rect::from_center_size(Vec2::ZERO, Vec2::new(100.0, 60.0)),
        },
        CameraBounds {
            min: Vec2::new(-500.0, -300.0),
            max: Vec2::new(500.0, 300.0),
        },
        CameraShake {
            intensity: 0.0,
            duration: Timer::from_seconds(0.3, TimerMode::Once),
            active: false,
        },
    ));
}
```

### æˆæœç‰©
- æ»‘ã‚‰ã‹ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½å¾“ã™ã‚‹ã‚«ãƒ¡ãƒ©
- ã‚¹ãƒ†ãƒ¼ã‚¸å¢ƒç•Œã§ã®ã‚«ãƒ¡ãƒ©åœæ­¢
- ãƒ€ãƒ¡ãƒ¼ã‚¸æ™‚ã®ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯

---

## Phase 9: ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆIï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ç›®æ¨™
åŸºæœ¬çš„ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 9.1 ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®åŸºç¤
- [ ] ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
- [ ] ã‚¨ãƒŸãƒƒã‚¿ãƒ¼
- [ ] ãƒ©ã‚¤ãƒ•ã‚¿ã‚¤ãƒ ã¨æ¶ˆæ»…

```rust
#[derive(Component)]
pub struct Particle {
    pub lifetime: Timer,
    pub initial_velocity: Vec2,
    pub gravity_scale: f32,
    pub fade_out: bool,
}

#[derive(Bundle)]
pub struct ParticleBundle {
    pub particle: Particle,
    pub velocity: Velocity,
    pub sprite: SpriteBundle,
}

fn update_particles(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut Particle, &mut Velocity, &mut Sprite)>,
) {
    for (entity, mut particle, mut velocity, mut sprite) in &mut query {
        particle.lifetime.tick(time.delta());

        // é‡åŠ›é©ç”¨
        velocity.y -= 200.0 * particle.gravity_scale * time.delta_seconds();

        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
        if particle.fade_out {
            let progress = particle.lifetime.fraction();
            if let Some(color) = &mut sprite.color {
                color.set_alpha(1.0 - progress);
            }
        }

        // å¯¿å‘½ãŒå°½ããŸã‚‰å‰Šé™¤
        if particle.lifetime.finished() {
            commands.entity(entity).despawn();
        }
    }
}

fn spawn_particle_burst(
    commands: &mut Commands,
    position: Vec2,
    count: usize,
    color: Color,
) {
    for _ in 0..count {
        let angle = rand::random::<f32>() * std::f32::consts::TAU;
        let speed = 50.0 + rand::random::<f32>() * 100.0;

        commands.spawn(ParticleBundle {
            particle: Particle {
                lifetime: Timer::from_seconds(1.0, TimerMode::Once),
                initial_velocity: Vec2::new(angle.cos(), angle.sin()) * speed,
                gravity_scale: 0.5,
                fade_out: true,
            },
            velocity: Velocity { x: 0.0, y: 0.0 },
            sprite: SpriteBundle {
                sprite: Sprite {
                    color,
                    custom_size: Some(Vec2::new(4.0, 4.0)),
                    ..default()
                },
                transform: Transform::from_translation(position.extend(1.0)),
                ..default()
            },
        });
    }
}
```

#### 9.2 ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] æ”»æ’ƒãƒ’ãƒƒãƒˆæ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ 

```rust
fn spawn_hit_effect(
    mut commands: Commands,
    assets: Res<GameAssets>,
    mut events: EventReader<DamageEvent>,
    query: Query<&Transform>,
) {
    for event in events.read() {
        if let Ok(transform) = query.get(event.target) {
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒ¼ã‚¹ãƒˆ
            spawn_particle_burst(
                &mut commands,
                transform.translation.truncate(),
                10,
                Color::srgb(1.0, 0.8, 0.0),
            );

            // ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
            commands.spawn((
                SpriteBundle {
                    texture: assets.slash_effect.clone(),
                    transform: Transform::from_translation(transform.translation),
                    ..default()
                },
                EffectLifetime(Timer::from_seconds(0.3, TimerMode::Once)),
                AnimationState {
                    current_frame: 0,
                    timer: Timer::from_seconds(0.05, TimerMode::Repeating),
                    playing: true,
                    looping: false,
                },
            ));
        }
    }
}
```

#### 9.3 ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—
ç”»é¢ã‚’ä¸€ç¬æ­¢ã‚ã¦ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆã‚’å¼·èª¿

- [ ] æ™‚é–“ã®åœæ­¢
- [ ] å¯¾è±¡ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã®é¸åˆ¥
- [ ] çŸ­æ™‚é–“ã§ã®å†é–‹

```rust
#[derive(Resource)]
pub struct HitStop {
    pub duration: Timer,
    pub active: bool,
}

fn trigger_hitstop(
    mut events: EventReader<DamageEvent>,
    mut hitstop: ResMut<HitStop>,
) {
    for _event in events.read() {
        hitstop.active = true;
        hitstop.duration = Timer::from_seconds(0.1, TimerMode::Once);
    }
}

fn update_hitstop(
    real_time: Res<Time<Real>>,
    mut virtual_time: ResMut<Time<Virtual>>,
    mut hitstop: ResMut<HitStop>,
) {
    if hitstop.active {
        hitstop.duration.tick(real_time.delta());

        if hitstop.duration.finished() {
            hitstop.active = false;
            virtual_time.unpause();
        } else {
            virtual_time.pause();
        }
    }
}
```

#### 9.4 ãƒˆãƒ¬ã‚¤ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] æ®‹åƒã®ç”Ÿæˆ
- [ ] ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
- [ ] ãƒ€ãƒƒã‚·ãƒ¥æ™‚ã®ãƒˆãƒ¬ã‚¤ãƒ«

```rust
#[derive(Component)]
pub struct Trail {
    pub spawn_timer: Timer,
    pub trail_lifetime: f32,
}

fn spawn_trail_effect(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(&Transform, &Sprite, &mut Trail)>,
) {
    for (transform, sprite, mut trail) in &mut query {
        trail.spawn_timer.tick(time.delta());

        if trail.spawn_timer.just_finished() {
            // æ®‹åƒã‚’ç”Ÿæˆ
            commands.spawn((
                SpriteBundle {
                    sprite: Sprite {
                        color: Color::srgba(sprite.color.red(), sprite.color.green(), sprite.color.blue(), 0.5),
                        ..sprite.clone()
                    },
                    transform: *transform,
                    ..default()
                },
                TrailGhost {
                    lifetime: Timer::from_seconds(trail.trail_lifetime, TimerMode::Once),
                },
            ));
        }
    }
}

#[derive(Component)]
pub struct TrailGhost {
    pub lifetime: Timer,
}

fn update_trail_ghosts(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut TrailGhost, &mut Sprite)>,
) {
    for (entity, mut ghost, mut sprite) in &mut query {
        ghost.lifetime.tick(time.delta());

        // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
        let alpha = 1.0 - ghost.lifetime.fraction();
        sprite.color.set_alpha(alpha * 0.5);

        if ghost.lifetime.finished() {
            commands.entity(entity).despawn();
        }
    }
}
```

#### 9.5 ã‚¸ãƒ£ãƒ³ãƒ—/ç€åœ°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] ã‚¸ãƒ£ãƒ³ãƒ—æ™‚ã®ç…™
- [ ] ç€åœ°æ™‚ã®è¡æ’ƒæ³¢

```rust
fn jump_effect(
    mut commands: Commands,
    query: Query<(&Transform, &GroundDetection), (With<Player>, Changed<GroundDetection>)>,
) {
    for (transform, ground) in &query {
        if !ground.is_grounded {
            // ã‚¸ãƒ£ãƒ³ãƒ—é–‹å§‹
            spawn_particle_burst(
                &mut commands,
                transform.translation.truncate() - Vec2::new(0.0, 16.0),
                5,
                Color::srgba(0.8, 0.8, 0.8, 0.7),
            );
        }
    }
}

fn land_effect(
    mut commands: Commands,
    assets: Res<GameAssets>,
    query: Query<(&Transform, &GroundDetection), (With<Player>, Changed<GroundDetection>)>,
) {
    for (transform, ground) in &query {
        if ground.is_grounded {
            // ç€åœ°
            commands.spawn((
                SpriteBundle {
                    texture: assets.land_effect.clone(),
                    transform: Transform::from_translation(
                        transform.translation - Vec3::new(0.0, 16.0, -1.0)
                    ),
                    ..default()
                },
                EffectLifetime(Timer::from_seconds(0.4, TimerMode::Once)),
            ));
        }
    }
}
```

### æˆæœç‰©
- æ”»æ’ƒãƒ’ãƒƒãƒˆæ™‚ã®æ´¾æ‰‹ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- ãƒ’ãƒƒãƒˆã‚¹ãƒˆãƒƒãƒ—ã§é‡é‡æ„Ÿã®ã‚ã‚‹æ”»æ’ƒ
- ãƒ€ãƒƒã‚·ãƒ¥æ™‚ã®ãƒˆãƒ¬ã‚¤ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ

---

## Phase 10: UIã‚·ã‚¹ãƒ†ãƒ Iï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ç›®æ¨™
åŸºæœ¬çš„ãªã‚²ãƒ¼ãƒ UIã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 10.1 HUDãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
- [ ] UIè¦ç´ ã®é…ç½®
- [ ] Flexboxçš„ãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ

```rust
fn setup_hud(mut commands: Commands) {
    commands
        .spawn(NodeBundle {
            style: Style {
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                flex_direction: FlexDirection::Column,
                justify_content: JustifyContent::SpaceBetween,
                ..default()
            },
            ..default()
        })
        .with_children(|parent| {
            // ä¸Šéƒ¨UIï¼ˆä½“åŠ›ã€ã‚¹ã‚³ã‚¢ï¼‰
            parent
                .spawn(NodeBundle {
                    style: Style {
                        width: Val::Percent(100.0),
                        height: Val::Px(60.0),
                        padding: UiRect::all(Val::Px(10.0)),
                        flex_direction: FlexDirection::Row,
                        justify_content: JustifyContent::SpaceBetween,
                        ..default()
                    },
                    background_color: Color::srgba(0.0, 0.0, 0.0, 0.5).into(),
                    ..default()
                })
                .with_children(|parent| {
                    // ä½“åŠ›è¡¨ç¤º
                    spawn_health_bar(parent);

                    // ã‚¹ã‚³ã‚¢è¡¨ç¤º
                    spawn_score_display(parent);
                });
        });
}
```

#### 10.2 ä½“åŠ›ãƒãƒ¼
- [ ] ãƒãƒ¼ãƒˆ/ãƒãƒ¼å½¢å¼ã®ä½“åŠ›è¡¨ç¤º
- [ ] ã‚¹ãƒ ãƒ¼ã‚ºãªæ¸›å°‘ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```rust
#[derive(Component)]
pub struct HealthBar {
    pub target_player: Entity,
    pub displayed_health: f32,
    pub animation_speed: f32,
}

fn update_health_bar(
    player_query: Query<&Health, With<Player>>,
    mut health_bar_query: Query<(&mut Style, &mut BackgroundColor, &mut HealthBar)>,
) {
    for (mut style, mut bg_color, mut health_bar) in &mut health_bar_query {
        if let Ok(health) = player_query.get(health_bar.target_player) {
            // ã‚¹ãƒ ãƒ¼ã‚ºã«æ¸›å°‘
            health_bar.displayed_health = health_bar.displayed_health.lerp(health.current, 0.1);

            let health_percent = (health_bar.displayed_health / health.max).clamp(0.0, 1.0);
            style.width = Val::Percent(health_percent * 100.0);

            // ä½“åŠ›ãŒå°‘ãªã„ã¨èµ¤ã
            if health_percent < 0.3 {
                *bg_color = Color::srgb(1.0, 0.0, 0.0).into();
            } else {
                *bg_color = Color::srgb(0.0, 1.0, 0.0).into();
            }
        }
    }
}

fn spawn_health_bar(parent: &mut ChildBuilder) {
    parent
        .spawn(NodeBundle {
            style: Style {
                width: Val::Px(200.0),
                height: Val::Px(30.0),
                border: UiRect::all(Val::Px(2.0)),
                ..default()
            },
            background_color: Color::srgb(0.2, 0.2, 0.2).into(),
            border_color: Color::WHITE.into(),
            ..default()
        })
        .with_children(|parent| {
            parent.spawn((
                NodeBundle {
                    style: Style {
                        width: Val::Percent(100.0),
                        height: Val::Percent(100.0),
                        ..default()
                    },
                    background_color: Color::srgb(0.0, 1.0, 0.0).into(),
                    ..default()
                },
                HealthBar {
                    target_player: Entity::PLACEHOLDER, // å¾Œã§è¨­å®š
                    displayed_health: 100.0,
                    animation_speed: 5.0,
                },
            ));
        });
}
```

#### 10.3 ã‚¹ã‚³ã‚¢è¡¨ç¤º
- [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¹ã‚³ã‚¢æ›´æ–°
- [ ] ã‚«ã‚¦ãƒ³ãƒˆã‚¢ãƒƒãƒ—ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```rust
#[derive(Resource)]
pub struct Score {
    pub value: u32,
}

#[derive(Component)]
pub struct ScoreText;

fn update_score_display(
    score: Res<Score>,
    mut query: Query<&mut Text, With<ScoreText>>,
) {
    for mut text in &mut query {
        text.sections[0].value = format!("Score: {}", score.value);
    }
}

fn spawn_score_display(parent: &mut ChildBuilder, asset_server: &AssetServer) {
    parent.spawn((
        TextBundle::from_section(
            "Score: 0",
            TextStyle {
                font: asset_server.load("fonts/pixelated.ttf"),
                font_size: 24.0,
                color: Color::WHITE,
            },
        ),
        ScoreText,
    ));
}
```

#### 10.4 ãƒœã‚¹ä½“åŠ›ãƒãƒ¼
- [ ] ç”»é¢ä¸Šéƒ¨ã®ãƒœã‚¹å°‚ç”¨ä½“åŠ›ãƒãƒ¼
- [ ] åå‰è¡¨ç¤º
- [ ] ç™»å ´ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```rust
#[derive(Component)]
pub struct BossHealthBar {
    pub boss_entity: Entity,
}

fn show_boss_health_bar(
    mut commands: Commands,
    boss_query: Query<(Entity, &Enemy, &Health), Added<Boss>>,
) {
    for (entity, enemy, health) in &boss_query {
        commands
            .spawn(NodeBundle {
                style: Style {
                    position_type: PositionType::Absolute,
                    top: Val::Px(10.0),
                    left: Val::Percent(50.0),
                    width: Val::Px(400.0),
                    height: Val::Px(40.0),
                    transform: Transform::from_translation(Vec3::new(-200.0, 0.0, 0.0)),
                    ..default()
                },
                background_color: Color::srgba(0.1, 0.1, 0.1, 0.9).into(),
                ..default()
            })
            .with_children(|parent| {
                // ãƒœã‚¹å
                parent.spawn(TextBundle::from_section(
                    &enemy.enemy_type,
                    TextStyle {
                        font_size: 20.0,
                        color: Color::WHITE,
                        ..default()
                    },
                ));

                // ä½“åŠ›ãƒãƒ¼
                parent.spawn((
                    NodeBundle {
                        style: Style {
                            width: Val::Percent(100.0),
                            height: Val::Px(10.0),
                            ..default()
                        },
                        background_color: Color::srgb(0.8, 0.0, 0.0).into(),
                        ..default()
                    },
                    BossHealthBar {
                        boss_entity: entity,
                    },
                ));
            });
    }
}
```

#### 10.5 ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼
- [ ] ãƒãƒ¼ã‚ºç”»é¢ã®UI
- [ ] å†é–‹/ãƒªãƒˆãƒ©ã‚¤/ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹
- [ ] å…¥åŠ›å‡¦ç†

```rust
fn setup_pause_menu(mut commands: Commands) {
    commands
        .spawn((
            NodeBundle {
                style: Style {
                    width: Val::Percent(100.0),
                    height: Val::Percent(100.0),
                    align_items: AlignItems::Center,
                    justify_content: JustifyContent::Center,
                    flex_direction: FlexDirection::Column,
                    ..default()
                },
                background_color: Color::srgba(0.0, 0.0, 0.0, 0.7).into(),
                visibility: Visibility::Hidden,
                ..default()
            },
            PauseMenu,
        ))
        .with_children(|parent| {
            parent.spawn(TextBundle::from_section(
                "PAUSED",
                TextStyle {
                    font_size: 48.0,
                    color: Color::WHITE,
                    ..default()
                },
            ));

            // ãƒœã‚¿ãƒ³
            spawn_menu_button(parent, "Resume", PauseMenuButton::Resume);
            spawn_menu_button(parent, "Retry", PauseMenuButton::Retry);
            spawn_menu_button(parent, "Title", PauseMenuButton::Title);
        });
}

#[derive(Component)]
enum PauseMenuButton {
    Resume,
    Retry,
    Title,
}

fn handle_pause_menu_buttons(
    mut interaction_query: Query<(&Interaction, &PauseMenuButton), Changed<Interaction>>,
    mut game_state: ResMut<NextState<InGameState>>,
) {
    for (interaction, button) in &mut interaction_query {
        if *interaction == Interaction::Pressed {
            match button {
                PauseMenuButton::Resume => {
                    game_state.set(InGameState::StagePlay);
                }
                PauseMenuButton::Retry => {
                    // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰
                }
                PauseMenuButton::Title => {
                    // ã‚¿ã‚¤ãƒˆãƒ«ã¸
                }
            }
        }
    }
}
```

### æˆæœç‰©
- ä½“åŠ›ãƒãƒ¼ã€ã‚¹ã‚³ã‚¢è¡¨ç¤ºã®HUD
- ãƒœã‚¹å‡ºç¾æ™‚ã®å°‚ç”¨UI
- ãƒãƒ¼ã‚ºãƒ¡ãƒ‹ãƒ¥ãƒ¼

---

## Phase 11: èƒ½åŠ›ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 5-6æ—¥ï¼‰

### ç›®æ¨™
ã‚«ãƒ¼ãƒ“ã‚£ã®ã‚³ãƒ”ãƒ¼èƒ½åŠ›ã®ã‚ˆã†ãªã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿè£…

### ã‚¿ã‚¹ã‚¯

#### 11.1 èƒ½åŠ›ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
- [ ] èƒ½åŠ›å®šç¾©ã®æ§‹é€ ä½“
- [ ] RONã‹ã‚‰ã®èª­ã¿è¾¼ã¿
- [ ] èƒ½åŠ›ä¸€è¦§ã®ç®¡ç†

```rust
#[derive(Resource)]
pub struct AbilityRegistry {
    pub abilities: HashMap<String, AbilityDefinition>,
}

#[derive(Clone, Deserialize)]
pub struct AbilityDefinition {
    pub id: String,
    pub name: String,
    pub description: String,
    pub icon_path: String,

    pub stats_modifier: StatsModifier,
    pub special_moves: Vec<SpecialMove>,

    pub animation_overrides: HashMap<String, AnimationClipRon>,
}

#[derive(Clone, Deserialize)]
pub struct StatsModifier {
    pub move_speed_multiplier: f32,
    pub jump_force_multiplier: f32,
    pub damage_multiplier: f32,
}

#[derive(Clone, Deserialize)]
pub enum SpecialMove {
    Projectile {
        damage: f32,
        speed: f32,
        sprite: String,
        cooldown: f32,
    },
    Melee {
        damage: f32,
        range: f32,
        knockback: f32,
    },
    Buff {
        duration: f32,
        effect: String,
    },
}
```

#### 11.2 èƒ½åŠ›å–å¾—ã‚·ã‚¹ãƒ†ãƒ 
- [ ] æ•µã‹ã‚‰ã®èƒ½åŠ›ãƒ‰ãƒ­ãƒƒãƒ—
- [ ] èƒ½åŠ›ã‚¢ã‚¤ãƒ†ãƒ ã®é…ç½®
- [ ] å–å¾—æ™‚ã®æ¼”å‡º

```rust
#[derive(Component)]
pub struct AbilityItem {
    pub ability_id: String,
}

fn pickup_ability(
    mut commands: Commands,
    player_query: Query<(Entity, &Transform, &Collider), With<Player>>,
    ability_item_query: Query<(Entity, &Transform, &Collider, &AbilityItem)>,
    mut ability_events: EventWriter<AbilityGainedEvent>,
) {
    for (player_entity, player_transform, player_collider) in &player_query {
        for (item_entity, item_transform, item_collider, ability_item) in &ability_item_query {
            if check_collision(player_transform, player_collider, item_transform, item_collider) {
                ability_events.send(AbilityGainedEvent {
                    player: player_entity,
                    ability_id: ability_item.ability_id.clone(),
                });

                commands.entity(item_entity).despawn();
            }
        }
    }
}

#[derive(Event)]
pub struct AbilityGainedEvent {
    pub player: Entity,
    pub ability_id: String,
}
```

#### 11.3 èƒ½åŠ›çŠ¶æ…‹ç®¡ç†
- [ ] ç¾åœ¨ã®èƒ½åŠ›ã®ä¿æŒ
- [ ] èƒ½åŠ›ã®åˆ‡ã‚Šæ›¿ãˆ
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è£œæ­£ã®é©ç”¨

```rust
#[derive(Component)]
pub struct CurrentAbility {
    pub ability_id: Option<String>,
}

fn apply_ability_stats(
    mut query: Query<(&CurrentAbility, &mut PlayerStats), Changed<CurrentAbility>>,
    registry: Res<AbilityRegistry>,
) {
    for (current, mut stats) in &mut query {
        // ãƒ™ãƒ¼ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
        *stats = PlayerStats::default();

        if let Some(ability_id) = &current.ability_id {
            if let Some(ability) = registry.abilities.get(ability_id) {
                stats.move_speed *= ability.stats_modifier.move_speed_multiplier;
                stats.jump_force *= ability.stats_modifier.jump_force_multiplier;
            }
        }
    }
}
```

#### 11.4 ç‰¹æ®ŠæŠ€ã®å®Ÿè£… - é£›ã³é“å…·

```rust
#[derive(Component)]
pub struct Projectile {
    pub damage: f32,
    pub speed: f32,
    pub lifetime: Timer,
    pub owner: Entity,
}

fn use_projectile_ability(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut commands: Commands,
    query: Query<(Entity, &Transform, &Player, &CurrentAbility)>,
    registry: Res<AbilityRegistry>,
    assets: Res<GameAssets>,
) {
    for (entity, transform, player, current_ability) in &query {
        if keyboard.just_pressed(KeyCode::KeyC) {
            if let Some(ability_id) = &current_ability.ability_id {
                if let Some(ability) = registry.abilities.get(ability_id) {
                    for special_move in &ability.special_moves {
                        if let SpecialMove::Projectile { damage, speed, sprite, cooldown } = special_move {
                            let direction = if player.facing_right { 1.0 } else { -1.0 };

                            commands.spawn((
                                Projectile {
                                    damage: *damage,
                                    speed: *speed,
                                    lifetime: Timer::from_seconds(5.0, TimerMode::Once),
                                    owner: entity,
                                },
                                Velocity {
                                    x: *speed * direction,
                                    y: 0.0,
                                },
                                SpriteBundle {
                                    texture: assets.projectiles.get(sprite).unwrap().clone(),
                                    transform: Transform::from_translation(transform.translation),
                                    ..default()
                                },
                                Collider {
                                    size: Vec2::new(16.0, 16.0),
                                    offset: Vec2::ZERO,
                                },
                            ));
                        }
                    }
                }
            }
        }
    }
}

fn update_projectiles(
    mut commands: Commands,
    time: Res<Time>,
    mut query: Query<(Entity, &mut Projectile)>,
) {
    for (entity, mut projectile) in &mut query {
        projectile.lifetime.tick(time.delta());

        if projectile.lifetime.finished() {
            commands.entity(entity).despawn();
        }
    }
}

fn projectile_hit_detection(
    mut commands: Commands,
    projectile_query: Query<(Entity, &Transform, &Collider, &Projectile)>,
    enemy_query: Query<(Entity, &Transform, &Collider), With<Enemy>>,
    mut damage_events: EventWriter<DamageEvent>,
) {
    for (proj_entity, proj_transform, proj_collider, projectile) in &projectile_query {
        for (enemy_entity, enemy_transform, enemy_collider) in &enemy_query {
            if check_collision(proj_transform, proj_collider, enemy_transform, enemy_collider) {
                damage_events.send(DamageEvent {
                    target: enemy_entity,
                    amount: projectile.damage,
                    source: DamageSource::Projectile(proj_entity),
                    knockback: Vec2::ZERO,
                });

                commands.entity(proj_entity).despawn();
            }
        }
    }
}
```

#### 11.5 ç‰¹æ®ŠæŠ€ - è¿‘æ¥æ”»æ’ƒå¼·åŒ–

```rust
fn use_melee_ability(
    keyboard: Res<ButtonInput<KeyCode>>,
    mut commands: Commands,
    query: Query<(Entity, &Transform, &Player, &CurrentAbility)>,
    registry: Res<AbilityRegistry>,
) {
    for (entity, transform, player, current_ability) in &query {
        if keyboard.just_pressed(KeyCode::KeyX) {
            if let Some(ability_id) = &current_ability.ability_id {
                if let Some(ability) = registry.abilities.get(ability_id) {
                    for special_move in &ability.special_moves {
                        if let SpecialMove::Melee { damage, range, knockback } = special_move {
                            let offset = if player.facing_right { *range } else { -*range };

                            commands.spawn((
                                Hitbox {
                                    damage: *damage,
                                    knockback: Vec2::new(offset * knockback, 100.0),
                                    hit_entities: HashSet::new(),
                                },
                                Collider {
                                    size: Vec2::new(*range, 30.0),
                                    offset: Vec2::new(offset / 2.0, 0.0),
                                },
                                Transform::from_translation(transform.translation),
                                AttackLifetime(Timer::from_seconds(0.3, TimerMode::Once)),
                            ));
                        }
                    }
                }
            }
        }
    }
}
```

#### 11.6 èƒ½åŠ›UI
- [ ] ç¾åœ¨ã®èƒ½åŠ›ã‚¢ã‚¤ã‚³ãƒ³è¡¨ç¤º
- [ ] èƒ½åŠ›åˆ‡ã‚Šæ›¿ãˆãƒ¡ãƒ‹ãƒ¥ãƒ¼

```rust
#[derive(Component)]
pub struct AbilityIcon;

fn update_ability_icon(
    player_query: Query<&CurrentAbility, (With<Player>, Changed<CurrentAbility>)>,
    mut icon_query: Query<&mut UiImage, With<AbilityIcon>>,
    registry: Res<AbilityRegistry>,
    assets: Res<GameAssets>,
) {
    for current_ability in &player_query {
        for mut icon in &mut icon_query {
            if let Some(ability_id) = &current_ability.ability_id {
                if let Some(ability) = registry.abilities.get(ability_id) {
                    *icon = assets.ability_icons.get(&ability.icon_path).unwrap().clone().into();
                }
            }
        }
    }
}
```

### æˆæœç‰©
- è¤‡æ•°ã®èƒ½åŠ›ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã‚‹
- èƒ½åŠ›ã«å¿œã˜ãŸç‰¹æ®ŠæŠ€ãŒä½¿ãˆã‚‹
- èƒ½åŠ›å–å¾—æ™‚ã®æ¼”å‡º

---

## Phase 12ä»¥é™ã®æ¦‚è¦

Phase 0-11ã§åŸºæœ¬çš„ãªã‚²ãƒ¼ãƒ ãŒéŠã¹ã‚‹çŠ¶æ…‹ã«ãªã‚Šã¾ã—ãŸã€‚Phase 12ä»¥é™ã§ã¯ã€ã‚ˆã‚Šé«˜åº¦ãªæ©Ÿèƒ½ã€ãƒãƒªãƒƒã‚·ãƒ¥ã€æœ€é©åŒ–ã‚’è¡Œã„ã¾ã™ã€‚

**Phase 12-20**: é«˜åº¦ãªã‚²ãƒ¼ãƒ ã‚·ã‚¹ãƒ†ãƒ ï¼ˆã‚³ãƒ³ãƒœã€ãƒœã‚¹ã€ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ç­‰ï¼‰
**Phase 21-27**: UI/UXæ”¹å–„ã€ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£
**Phase 28-31**: ã‚„ã‚Šè¾¼ã¿è¦ç´ ã€æœ€é©åŒ–ã€ãƒãƒªãƒƒã‚·ãƒ¥
**Phase 32**: ã‚ªãƒ—ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³ï¼‰

è©³ç´°ãªå®Ÿè£…å†…å®¹ã¯å„ãƒ•ã‚§ãƒ¼ã‚ºã§æ®µéšçš„ã«è¿½åŠ ã—ã¦ã„ãã¾ã™ã€‚

---

## ã¾ã¨ã‚ã¨æ¨å¥¨å­¦ç¿’ãƒ‘ã‚¹

### ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ‘ã‚¹ï¼ˆæœ€å°é™ã®å®Ÿè£…ï¼‰
Phase 0 â†’ 1 â†’ 2 â†’ 4 â†’ 5 â†’ 6 â†’ 7 â†’ 8 â†’ 10 â†’ 15 â†’ 16

ã“ã‚Œã ã‘ã§ã€Œå‹•ãã‚²ãƒ¼ãƒ ã€ã«ãªã‚Šã¾ã™ã€‚

### å®Œå…¨å®Ÿè£…ãƒ‘ã‚¹
Phase 0-31ã‚’é †ç•ªã«å®Ÿè£…

æ¨å®šç·é–‹ç™ºæ™‚é–“: **6-12ãƒ¶æœˆ**ï¼ˆé€±10-20æ™‚é–“ã®ä½œæ¥­ã¨ä»®å®šï¼‰

### å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹

#### Bevy
- [Bevyå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://bevyengine.org/learn/)
- [Bevy Cheatbook](https://bevy-cheatbook.github.io/)
- [Bevy Examples](https://github.com/bevyengine/bevy/tree/main/examples)

#### ã‚²ãƒ¼ãƒ è¨­è¨ˆ
- ["Game Programming Patterns" by Robert Nystrom](https://gameprogrammingpatterns.com/)
- ["Game Feel" by Steve Swink](https://www.amazon.com/dp/0123743281)

#### 2Dã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ åˆ†æ
- [Celeste Movement Analysis](https://www.youtube.com/watch?v=yorTG9at90g)
- [Hollow Knight Design Analysis](https://www.youtube.com/watch?v=7ITtPRparcã—ã‚‡)

### é€²æ—è¨˜éŒ²ã®æ¨å¥¨

`docs/implementation_log.md`ã«ä»¥ä¸‹ã‚’è¨˜éŒ²ï¼š
- å®Ÿè£…ã—ãŸæ—¥ä»˜
- å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯
- é­é‡ã—ãŸå•é¡Œã¨è§£æ±ºæ–¹æ³•
- å­¦ã‚“ã ã“ã¨
- æ¬¡ã«å–ã‚Šçµ„ã‚€ã“ã¨

---

## Phase 12-32ã®è©³ç´°å®Ÿè£…è¨ˆç”»

ä»¥ä¸‹ã€Phase 12ä»¥é™ã®ç°¡æ˜“ç‰ˆãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã§ã™ã€‚å„ãƒ•ã‚§ãƒ¼ã‚ºã®è©³ç´°å®Ÿè£…ä¾‹ã¯ã€å®Ÿéš›ã«å®Ÿè£…ã™ã‚‹éš›ã«æ®µéšçš„ã«è¿½åŠ ã—ã¦ã„ãã¾ã™ã€‚

---

## Phase 12: æˆ¦é—˜ã‚·ã‚¹ãƒ†ãƒ II - ã‚³ãƒ³ãƒœãƒ»ãƒ‘ãƒªã‚£ï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚³ãƒ³ãƒœã‚·ã‚¹ãƒ†ãƒ ï¼ˆé€£ç¶šæ”»æ’ƒï¼‰
- [ ] ãƒ‘ãƒªã‚£/ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ã‚¸ãƒ£ã‚°ãƒªãƒ³ã‚°ï¼ˆæ•µã‚’æµ®ã‹ã›ã‚‹ï¼‰
- [ ] ã‚¨ã‚¢ã‚³ãƒ³ãƒœ
- [ ] ãƒ•ã‚£ãƒ‹ãƒƒã‚·ãƒ¥ãƒ ãƒ¼ãƒ–

---

## Phase 13: æ•µã‚·ã‚¹ãƒ†ãƒ II - é«˜åº¦ãªAIï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ãƒ™ãƒ¼ã‚¹ã®AI
- [ ] å”èª¿æ”»æ’ƒï¼ˆè¤‡æ•°ã®æ•µãŒé€£æºï¼‰
- [ ] å­¦ç¿’å‹AIï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ãƒ‘ã‚¿ãƒ¼ãƒ³ã«å¯¾å¿œï¼‰
- [ ] æ•µã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆè‰²é•ã„ã§å¼·åŒ–ç‰ˆï¼‰
- [ ] ã‚¨ãƒªãƒ¼ãƒˆã‚¨ãƒãƒŸãƒ¼ï¼ˆãƒŸãƒ‹ãƒœã‚¹ï¼‰

---

## Phase 14: ãƒœã‚¹ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 6-7æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ãƒœã‚¹å°‚ç”¨AI
- [ ] ãƒ•ã‚§ãƒ¼ã‚ºåˆ¶ï¼ˆä½“åŠ›ã«å¿œã˜ã¦æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³å¤‰åŒ–ï¼‰
- [ ] ãƒœã‚¹å°‚ç”¨ã‚«ãƒ¡ãƒ©ãƒ¯ãƒ¼ã‚¯
- [ ] ãƒœã‚¹æˆ¦ç”¨BGM
- [ ] ãƒœã‚¹æ’ƒç ´æ¼”å‡º
- [ ] å¼±ç‚¹ã‚·ã‚¹ãƒ†ãƒ 

---

## Phase 15: ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠUI
- [ ] ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒƒãƒ—ã®æç”»
- [ ] ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¸æƒ…å ±è¡¨ç¤º
- [ ] ã‚¢ãƒ³ãƒ­ãƒƒã‚¯æ¼”å‡º

---

## Phase 16: é€²è¡Œç®¡ç† - ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®å®Ÿè£…
- [ ] ã‚»ãƒ¼ãƒ–å‡¦ç†ï¼ˆRONå½¢å¼ï¼‰
- [ ] ãƒ­ãƒ¼ãƒ‰å‡¦ç†
- [ ] è¤‡æ•°ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆ
- [ ] ã‚ªãƒ¼ãƒˆã‚»ãƒ¼ãƒ–
- [ ] ã‚»ãƒ¼ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«ç ´æå¯¾ç­–

---

## Phase 17: UIã‚·ã‚¹ãƒ†ãƒ II - ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å€¤ç­‰ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ãƒ€ãƒ¡ãƒ¼ã‚¸æ•°å€¤è¡¨ç¤ºï¼ˆãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ï¼‰
- [ ] ãƒŸãƒ‹ãƒãƒƒãƒ—
- [ ] ã‚¯ã‚¨ã‚¹ãƒˆãƒ­ã‚°
- [ ] ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªUI
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢

---

## Phase 18: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ Iï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] BGMå†ç”Ÿã‚·ã‚¹ãƒ†ãƒ 
- [ ] åŠ¹æœéŸ³ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ãƒœãƒªãƒ¥ãƒ¼ãƒ åˆ¶å¾¡
- [ ] ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆ
- [ ] ã‚¹ãƒ†ãƒ¼ã‚¸åˆ¥BGM
- [ ] ãƒœã‚¹æˆ¦å°‚ç”¨BGM

---

## Phase 19: ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆII - ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ï¼ˆäºˆæƒ³æ™‚é–“: 5-6æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚«ã‚¹ã‚¿ãƒ ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®å®Ÿè£…
- [ ] ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ã‚°ãƒ­ãƒ¼åŠ¹æœ
- [ ] ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¹ãƒšãƒ¼ã‚¹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
- [ ] å¤©å€™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆé›¨ã€é›ªï¼‰
- [ ] æ°´é¢åå°„

---

## Phase 20: ãƒ¬ãƒ™ãƒ«ã‚®ãƒŸãƒƒã‚¯ï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ç§»å‹•åºŠ
- [ ] ã‚¹ã‚¤ãƒƒãƒã¨æ‰‰
- [ ] ãƒ¯ãƒ¼ãƒ—ã‚¾ãƒ¼ãƒ³
- [ ] ãƒˆãƒ©ãƒƒãƒ—ï¼ˆãƒˆã‚²ã€è½ã¨ã—ç©´ï¼‰
- [ ] ç ´å£Šå¯èƒ½ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
- [ ] éš ã—éƒ¨å±‹

---

## Phase 21: ã‚«ãƒ¡ãƒ©ã‚·ã‚¹ãƒ†ãƒ IIï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚«ãƒ¡ãƒ©å…ˆèª­ã¿ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ãå…ˆï¼‰
- [ ] ã‚«ãƒ¡ãƒ©ã‚¾ãƒ¼ãƒ³ï¼ˆã‚¨ãƒªã‚¢ã”ã¨ã®è¨­å®šï¼‰
- [ ] ã‚ºãƒ¼ãƒ ã‚¤ãƒ³/ã‚¢ã‚¦ãƒˆ
- [ ] ã‚·ãƒãƒãƒ†ã‚£ãƒƒã‚¯ã‚«ãƒ¡ãƒ©
- [ ] ãƒœã‚¹æˆ¦ã‚«ãƒ¡ãƒ©ãƒ­ãƒƒã‚¯

---

## Phase 22: åé›†è¦ç´ ãƒ»å®Ÿç¸¾ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] åé›†ã‚¢ã‚¤ãƒ†ãƒ ã‚·ã‚¹ãƒ†ãƒ 
- [ ] å®Ÿç¸¾/ãƒˆãƒ­ãƒ•ã‚£ãƒ¼ã‚·ã‚¹ãƒ†ãƒ 
- [ ] é€²æ—ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
- [ ] å ±é…¬ã‚·ã‚¹ãƒ†ãƒ 
- [ ] éš ã—ã‚¢ã‚¤ãƒ†ãƒ 

---

## Phase 23: ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã‚·ã‚¹ãƒ†ãƒ II - ã‚¢ãƒ€ãƒ—ãƒ†ã‚£ãƒ–ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯ï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‰éŸ³æ¥½ï¼ˆçŠ¶æ³ã«å¿œã˜ã¦æ¥½å™¨è¿½åŠ ï¼‰
- [ ] 3Dç©ºé–“ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
- [ ] ãƒªãƒãƒ¼ãƒ–/ã‚¨ã‚³ãƒ¼
- [ ] ãƒ€ã‚¤ãƒŠãƒŸãƒƒã‚¯ãƒŸãƒ¥ãƒ¼ã‚¸ãƒƒã‚¯ï¼ˆæˆ¦é—˜æ™‚ã«æ¿€ã—ãï¼‰
- [ ] éŸ³ã®è·é›¢æ¸›è¡°

---

## Phase 24: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–Iï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒªãƒ³ã‚°
- [ ] ãƒ•ãƒ©ã‚¹ã‚¿ãƒ ã‚«ãƒªãƒ³ã‚°
- [ ] LOD (Level of Detail)
- [ ] éåŒæœŸãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
- [ ] ãƒ¡ãƒ¢ãƒªç®¡ç†ã®æ”¹å–„
- [ ] ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°ã¨ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç‰¹å®š

---

## Phase 25: ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚«ãƒ©ãƒ¼ãƒ–ãƒ©ã‚¤ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
- [ ] å­—å¹•è¡¨ç¤º
- [ ] ãƒœã‚¿ãƒ³é…ç½®ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚º
- [ ] é›£æ˜“åº¦èª¿æ•´ã‚ªãƒ—ã‚·ãƒ§ãƒ³
- [ ] ã‚¢ã‚·ã‚¹ãƒˆæ©Ÿèƒ½ï¼ˆè‡ªå‹•å›é¿ç­‰ï¼‰
- [ ] UIæ‹¡å¤§ã‚ªãƒ—ã‚·ãƒ§ãƒ³

---

## Phase 26: ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°
- [ ] ã‚¬ã‚¤ãƒ‰çŸ¢å°
- [ ] æ“ä½œèª¬æ˜ã®è¡¨ç¤º
- [ ] ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€²è¡Œã«å¿œã˜ãŸãƒ’ãƒ³ãƒˆ
- [ ] ã‚¹ã‚­ãƒƒãƒ—å¯èƒ½ãªãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«

---

## Phase 27: ã‚«ãƒƒãƒˆã‚·ãƒ¼ãƒ³/ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ï¼ˆäºˆæƒ³æ™‚é–“: 4-5æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ç«‹ã¡çµµ
- [ ] ãƒ†ã‚­ã‚¹ãƒˆé€ã‚Š
- [ ] é¸æŠè‚¢ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ã‚«ãƒƒãƒˆã‚·ãƒ¼ãƒ³å†ç”Ÿ
- [ ] ã‚¹ã‚­ãƒƒãƒ—æ©Ÿèƒ½

---

## Phase 28: ã‚¿ã‚¤ãƒ ã‚¢ã‚¿ãƒƒã‚¯/ã‚¹ã‚³ã‚¢ã‚¢ã‚¿ãƒƒã‚¯ï¼ˆäºˆæƒ³æ™‚é–“: 2-3æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚¿ã‚¤ãƒ ã‚¢ã‚¿ãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰
- [ ] ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ã‚´ãƒ¼ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
- [ ] ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ãƒªãƒ—ãƒ¬ã‚¤ä¿å­˜

---

## Phase 29: ãƒªãƒ—ãƒ¬ã‚¤ã‚·ã‚¹ãƒ†ãƒ ï¼ˆäºˆæƒ³æ™‚é–“: 5-6æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] å…¥åŠ›è¨˜éŒ²ã‚·ã‚¹ãƒ†ãƒ 
- [ ] ãƒªãƒ—ãƒ¬ã‚¤å†ç”Ÿ
- [ ] ã‚´ãƒ¼ã‚¹ãƒˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º
- [ ] ãƒªãƒ—ãƒ¬ã‚¤ãƒ•ã‚¡ã‚¤ãƒ«ç®¡ç†
- [ ] æ—©é€ã‚Š/ã‚¹ãƒ­ãƒ¼å†ç”Ÿ

---

## Phase 30: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–IIï¼ˆäºˆæƒ³æ™‚é–“: 3-4æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] æœ€çµ‚çš„ãªãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒªãƒ³ã‚°
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ä¿®æ­£
- [ ] ãƒ­ãƒ¼ãƒ‰æ™‚é–“çŸ­ç¸®
- [ ] ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆå®‰å®šåŒ–
- [ ] ãƒãƒƒãƒ†ãƒªãƒ¼æ¶ˆè²»æœ€é©åŒ–ï¼ˆãƒ©ãƒƒãƒ—ãƒˆãƒƒãƒ—å‘ã‘ï¼‰

---

## Phase 31: ãƒãƒªãƒƒã‚·ãƒ¥ï¼ˆäºˆæƒ³æ™‚é–“: 5-7æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ãƒã‚°ä¿®æ­£
- [ ] ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å¾®èª¿æ•´
- [ ] ã‚µã‚¦ãƒ³ãƒ‰ãƒãƒ©ãƒ³ã‚¹èª¿æ•´
- [ ] UI/UXæ”¹å–„
- [ ] ãƒ—ãƒ¬ã‚¤ãƒ†ã‚¹ãƒˆãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å¯¾å¿œ
- [ ] æœ€çµ‚èª¿æ•´

---

## Phase 32 (ã‚ªãƒ—ã‚·ãƒ§ãƒ³): ã‚ªãƒ³ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½ï¼ˆäºˆæƒ³æ™‚é–“: 10-15æ—¥ï¼‰

### ã‚¿ã‚¹ã‚¯
- [ ] ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ãƒªãƒ¼ãƒ€ãƒ¼ãƒœãƒ¼ãƒ‰
- [ ] ã‚´ãƒ¼ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿å…±æœ‰
- [ ] å”åŠ›ãƒ—ãƒ¬ã‚¤ï¼ˆ2Pï¼‰
- [ ] å¯¾æˆ¦ãƒ¢ãƒ¼ãƒ‰
- [ ] ãƒ•ãƒ¬ãƒ³ãƒ‰æ©Ÿèƒ½
- [ ] ã‚µãƒ¼ãƒãƒ¼/APIå®Ÿè£…

**æ³¨**: ã“ã®æ©Ÿèƒ½ã¯éå¸¸ã«é«˜åº¦ã§ã€åˆ¥é€”ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã®çŸ¥è­˜ãŒå¿…è¦ã§ã™ã€‚

---

## å®Œå…¨å®Ÿè£…å¾Œã®è¿½åŠ ã‚¢ã‚¤ãƒ‡ã‚¢

### DLC/æ‹¡å¼µã‚³ãƒ³ãƒ†ãƒ³ãƒ„
- æ–°ã—ã„ãƒ¯ãƒ¼ãƒ«ãƒ‰
- æ–°ã—ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼
- æ–°ã—ã„èƒ½åŠ›
- ãƒœã‚¹ãƒ©ãƒƒã‚·ãƒ¥ãƒ¢ãƒ¼ãƒ‰
- é«˜é›£æ˜“åº¦ãƒ¢ãƒ¼ãƒ‰

### ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£æ©Ÿèƒ½
- ãƒ¬ãƒ™ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼
- ã‚«ã‚¹ã‚¿ãƒ ã‚¹ãƒ†ãƒ¼ã‚¸å…±æœ‰
- MODã‚µãƒãƒ¼ãƒˆ

---

ã“ã®ãƒ­ãƒ¼ãƒ‰ãƒãƒƒãƒ—ã«æ²¿ã£ã¦å®Ÿè£…ã‚’é€²ã‚ã‚‹ã“ã¨ã§ã€ç¾ä»£çš„ã§æ´—ç·´ã•ã‚ŒãŸ2Dã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ãƒ ãŒå®Œæˆã—ã¾ã™ã€‚å„ãƒ•ã‚§ãƒ¼ã‚ºã¯ç‹¬ç«‹ã—ã¦ã„ã‚‹ãŸã‚ã€èˆˆå‘³ã®ã‚ã‚‹éƒ¨åˆ†ã‹ã‚‰å®Ÿè£…ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚

**é‡è¦**: å…¨ã¦ã‚’å®Œç’§ã«å®Ÿè£…ã™ã‚‹å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚è‡ªåˆ†ã®ãƒšãƒ¼ã‚¹ã§ã€æ¥½ã—ã¿ãªãŒã‚‰å­¦ã‚“ã§ã„ãã¾ã—ã‚‡ã†ï¼